From abfb31e53a139018edf840b449f01a6972f1d654 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ond=C5=99ej=20Hlavat=C3=BD?= <aearsis@eideo.cz>
Date: Fri, 27 May 2016 02:40:34 +0200
Subject: [PATCH 4/4] Added the PIM protocol

---
 configure.in        |    4 +-
 lib/ip.h            |    2 +
 nest/proto.c        |    2 +
 nest/protocol.h     |    2 +-
 nest/route.h        |    1 +
 proto/pim/Makefile  |    4 +
 proto/pim/config.Y  |  102 ++++
 proto/pim/df.c      |  330 +++++++++++++
 proto/pim/packets.c |  647 ++++++++++++++++++++++++++
 proto/pim/pim.c     | 1281 +++++++++++++++++++++++++++++++++++++++++++++++++++
 proto/pim/pim.h     |  335 ++++++++++++++
 11 files changed, 2707 insertions(+), 3 deletions(-)
 create mode 100644 proto/pim/Makefile
 create mode 100644 proto/pim/config.Y
 create mode 100644 proto/pim/df.c
 create mode 100644 proto/pim/packets.c
 create mode 100644 proto/pim/pim.c
 create mode 100644 proto/pim/pim.h

diff --git a/configure.in b/configure.in
index 8c100b6..1efbd83 100644
--- a/configure.in
+++ b/configure.in
@@ -167,8 +167,8 @@ fi
 
 AC_SUBST(iproutedir)
 
-# all_protocols="$proto_bfd babel bgp igmp ospf pipe radv rip static"
-all_protocols="$proto_bfd igmp ospf pipe radv rip static"
+# all_protocols="$proto_bfd babel bgp igmp ospf pim pipe radv rip static"
+all_protocols="$proto_bfd igmp ospf pim pipe radv rip static"
 
 all_protocols=`echo $all_protocols | sed 's/ /,/g'`
 
diff --git a/lib/ip.h b/lib/ip.h
index d73ef80..be547aa 100644
--- a/lib/ip.h
+++ b/lib/ip.h
@@ -21,6 +21,7 @@
 #define IP4_OSPF_DES_ROUTERS	ipa_build4(224, 0, 0, 6)
 #define IP4_RIP_ROUTERS		ipa_build4(224, 0, 0, 9)
 #define IP4_IGMP_ROUTERS	ipa_build4(224, 0, 0, 22)
+#define IP4_PIM_ROUTERS		ipa_build4(224, 0, 0, 13)
 
 #define IP6_ALL_NODES		ipa_build6(0xFF020000, 0, 0, 1)
 #define IP6_ALL_ROUTERS		ipa_build6(0xFF020000, 0, 0, 2)
@@ -28,6 +29,7 @@
 #define IP6_OSPF_DES_ROUTERS	ipa_build6(0xFF020000, 0, 0, 6)
 #define IP6_RIP_ROUTERS		ipa_build6(0xFF020000, 0, 0, 9)
 #define IP6_BABEL_ROUTERS	ipa_build6(0xFF020000, 0, 0, 0x00010006)
+#define IP6_PIM_ROUTERS		ipa_build6(0xff020000, 0, 0, 13)
 
 #define IP4_NONE		_MI4(0)
 #define IP6_NONE		_MI6(0,0,0,0)
diff --git a/nest/proto.c b/nest/proto.c
index 634ac51..162c25d 100644
--- a/nest/proto.c
+++ b/nest/proto.c
@@ -1264,6 +1264,8 @@ protos_build(void)
 #endif
 #ifdef CONFIG_IGMP
   proto_build(&proto_igmp);
+#ifdef CONFIG_PIM
+  proto_build(&proto_pim);
 #endif
 
   proto_pool = rp_new(&root_pool, "Protocols");
diff --git a/nest/protocol.h b/nest/protocol.h
index 14ebb88..a1f20ea 100644
--- a/nest/protocol.h
+++ b/nest/protocol.h
@@ -82,7 +82,7 @@ void protos_dump_all(void);
 extern struct protocol
   proto_device, proto_radv, proto_rip, proto_static,
   proto_ospf, proto_pipe, proto_bgp, proto_bfd,
-  proto_igmp;
+  proto_igmp, proto_pim;
 
 /*
  *	Routing Protocol Instance
diff --git a/nest/route.h b/nest/route.h
index 4d61511..6003c3e 100644
--- a/nest/route.h
+++ b/nest/route.h
@@ -400,6 +400,7 @@ typedef struct rta {
 #define RTS_PIPE 12			/* Inter-table wormhole */
 #define RTS_BABEL 13			/* Babel route */
 #define RTS_IGMP 14			/* IGMP multicast request */
+#define RTS_PIM 15			/* PIM multicast request */
 
 #define RTC_UNICAST 0
 #define RTC_BROADCAST 1
diff --git a/proto/pim/Makefile b/proto/pim/Makefile
new file mode 100644
index 0000000..33f18f6
--- /dev/null
+++ b/proto/pim/Makefile
@@ -0,0 +1,4 @@
+src := pim.c packets.c df.c
+obj := $(src-o-files)
+$(all-daemon)
+$(cf-local)
diff --git a/proto/pim/config.Y b/proto/pim/config.Y
new file mode 100644
index 0000000..b39ca0c
--- /dev/null
+++ b/proto/pim/config.Y
@@ -0,0 +1,102 @@
+/*
+ *  BIRD -- PIM protocol
+ *
+ *  (c) 2016 Ondrej Hlavaty <aearsis@eideo.cz>
+ *
+ *  Can be freely distributed and used under the terms of the GNU GPL.
+ */
+
+CF_HDR
+
+#include "proto/pim/pim.h"
+
+CF_DEFINES
+
+#define PIM_CFG ((struct pim_config *) this_proto)
+#define PIM_IFACE ((struct pim_iface_config *) this_ipatt)
+
+static struct pim_grp_config *this_group;
+
+CF_DECLS
+
+CF_KEYWORDS(PIM, GROUP, RPA, SUBSCRIBE, HELLO, PERIOD, DELAY, HOLDTIME)
+CF_KEYWORDS(ELECTION, ROBUSTNESS, OVERRIDE, INTERVAL, JOINPRUNE, SUPPRESSION)
+
+CF_GRAMMAR
+
+CF_ADDTO(proto, pim_proto '}' { pim_config_finish(PIM_CFG); } )
+
+pim_proto_start: proto_start PIM {
+   this_proto = proto_config_new(&proto_pim, $1);
+   pim_config_init(PIM_CFG);
+ }
+ ;
+
+pim_proto:
+   pim_proto_start proto_name '{'
+ | pim_proto pim_proto_item ';'
+ ;
+
+pim_proto_item:
+   proto_item
+ | proto_channel
+ | pim_group
+ | INTERFACE pim_iface
+ ;
+
+pim_group_start:
+ GROUP net_or_ipa {
+  this_group = cfg_allocz(sizeof(struct pim_grp_config));
+  add_tail(&PIM_CFG->grp_list, NODE this_group);
+  this_group->ga = $2; 
+ }
+ ;
+
+pim_group_item:
+ RPA ipa { this_group->rpa = $2; }
+ ;
+
+pim_group_opts:
+   /* empty */
+ | pim_group_opts pim_group_item ';'
+ ;
+
+pim_group:
+  pim_group_start '{' pim_group_opts '}'
+ ;
+
+pim_iface_start:
+{
+  this_ipatt = cfg_allocz(sizeof(struct pim_iface_config));
+  add_tail(&PIM_CFG->patt_list, NODE this_ipatt);
+  pim_iface_config_init(PIM_IFACE);
+};
+
+pim_iface_item:
+   HELLO PERIOD expr_us { PIM_IFACE->hello_int = $3; }
+ | HELLO DELAY expr_us { PIM_IFACE->hello_dly = $3; }
+ | HELLO HOLDTIME expr_us { PIM_IFACE->hello_holdtime = $3; }
+ | ELECTION ROBUSTNESS expr { PIM_IFACE->election_robustness = $3; }
+ | OVERRIDE INTERVAL expr_us { PIM_IFACE->override_interval = $3; }
+ | JOINPRUNE PERIOD expr_us { PIM_IFACE->jp_periodic = $3; }
+ | JOINPRUNE HOLDTIME expr_us { PIM_IFACE->jp_holdtime = $3; }
+ ;
+
+pim_iface_opts:
+   /* empty */
+ | pim_iface_opts pim_iface_item ';'
+ ;
+
+pim_iface_opt_list:
+   /* empty */
+ | '{' pim_iface_opts '}'
+ ;
+
+pim_iface:
+  pim_iface_start iface_patt_list_nopx pim_iface_opt_list { pim_iface_config_finish(PIM_IFACE); }
+
+
+
+CF_CODE
+
+CF_END
diff --git a/proto/pim/df.c b/proto/pim/df.c
new file mode 100644
index 0000000..1a6593d
--- /dev/null
+++ b/proto/pim/df.c
@@ -0,0 +1,330 @@
+/*
+ *	BIRD -- PIM protocol
+ *
+ *	Can be freely distributed and used under the terms of the GNU GPL.
+ */
+
+#include <stdlib.h>
+#include "pim.h"
+
+static inline void
+df_send(struct pim_rp_iface *rpi, uint type, ip_addr *target, struct pim_metric *target_metric)
+{
+  struct pim_df_msg msg;
+  msg.type = type;
+  msg.rpa = rpi->rp->rpa;
+  msg.metric = pim_get_metric(rpi);
+
+  if (target && target_metric)
+  {
+    msg.target = *target;
+    msg.target_metric = *target_metric;
+  }
+
+  if (type == PIM_DF_BACKOFF)
+    msg.backoff_interval = PIM_BACKOFF_PERIOD;
+
+  pim_send_df(rpi, &msg);
+}
+
+static inline void
+df_set_df(struct pim_rp_iface *rpi, struct pim_neigh *df, struct pim_metric metric)
+{
+  rpi->df_metric = metric;
+  if (rpi->df == df)
+    return;
+
+  if (rpi->df)
+    rem_node(&rpi->df_node);
+
+  pim_upstream_neighbor_change(rpi->rp, rpi->df, df);
+
+  rpi->df = df;
+
+  if (df)
+    add_tail(&df->df_list, &rpi->df_node);
+}
+
+static inline void
+df_set_bo(struct pim_rp_iface *rpi, struct pim_neigh *bo, struct pim_metric metric)
+{
+  rpi->bo_metric = metric;
+  if (rpi->bo)
+    rem_node(&rpi->bo_node);
+  rpi->bo = bo;
+  if (bo)
+    add_tail(&bo->bo_list, &rpi->bo_node);
+}
+
+static inline void
+df_set_state(struct pim_rp_iface *rpi, uint state)
+{
+  if (rpi->election_state == state)
+    return;
+
+  int was_df = RPI_IS_DF(rpi);
+  rpi->election_state = state;
+  if (RPI_IS_DF(rpi))
+    df_set_df(rpi, NULL, rpi->rp->rp_metric);
+
+  if (was_df != RPI_IS_DF(rpi))
+    pim_rp_update_routing(rpi->rp);
+}
+
+
+#define OP_HIGH (rpi->iface->cf->election_robustness * PIM_OFFER_PERIOD)
+#define OP_LOW (PIM_OFFER_PERIOD * (random() & 128 + 128) / 256)
+
+#define DFT(x)			tm_start_btime(rpi->election_timer, x)
+#define DFT_LOWER(x)		tm_start_min_btime(rpi->election_timer, x);
+#define DFT_STOP		tm_stop(rpi->election_timer)
+#define MC(x)			rpi->mc = x
+#define STATE(X)		df_set_state(rpi, PIM_DF_##X);
+#define SEND(X)			df_send(rpi, PIM_DF_##X, NULL, NULL)
+#define SEND_TARGET(X,y,z)	df_send(rpi, PIM_DF_##X, &y, &z)
+#define DF_SENDER		df_set_df(rpi, msg->sender, msg->metric)
+#define DF_TARGET		df_set_df(rpi, pim_neigh_from_neighbor(target), msg->target_metric)
+
+#define CASE(state, better, msg) ((state << 4) | (msg << 1) | (better != 0))
+#define C(state, better, msg) CASE(PIM_DF_##state, better, PIM_DF_##msg)
+
+#define BETTER	1
+#define WORSE	0
+
+/*
+ * This method handles the 21 different cases, so it's quite nasty.
+ */
+void
+pim_df_message(struct pim_rp_iface *rpi, struct pim_df_msg *msg)
+{
+  neighbor *target = NULL;
+  char better;
+
+  if (msg->type >= PIM_DF_BACKOFF)
+  {
+    target = neigh_find2(&rpi->iface->proto->p, &msg->target, rpi->iface->iface, 0);
+
+    if (target && target->scope == SCOPE_HOST)
+    {
+      // struct pim_proto *p = rpi->rp->proto;
+      if (rpi->election_state == PIM_DF_OFFER)
+      {
+	if (msg->type == PIM_DF_PASS)
+	{
+	  STATE(WINNER);
+	  DFT_STOP;
+	}
+	else
+	{
+	  DFT(OP_LOW + msg->backoff_interval);
+	  MC(0);
+	}
+      }
+      else
+      {
+	STATE(OFFER);
+	DFT(OP_LOW);
+	MC(0);
+      }
+      return;
+    }
+
+    better = pim_metric_better(&msg->target_metric, &rpi->rp->rp_metric, &msg->target, &rpi->iface->iface->addr->ip);
+  }
+  else
+    better = pim_metric_better(&msg->metric, &rpi->rp->rp_metric, &msg->sender->neigh->addr,  &rpi->iface->iface->addr->ip);
+
+  switch (CASE(rpi->election_state, better, msg->type))
+    {
+      case C(LOSE, BETTER, OFFER):
+	STATE(OFFER);
+      case C(OFFER, BETTER, OFFER):
+	DFT(OP_HIGH);
+	MC(0);
+	return;
+
+      case C(WINNER, BETTER, OFFER):
+	STATE(BACKOFF);
+      case C(BACKOFF, BETTER, OFFER):
+	if (!rpi->bo || pim_metric_better(&msg->metric, &rpi->bo_metric, &msg->sender->neigh->addr, &rpi->bo->neigh->addr))
+	  df_set_bo(rpi, msg->sender, msg->metric);
+	SEND_TARGET(BACKOFF, msg->sender->neigh->addr, rpi->bo_metric);
+	DFT(PIM_BACKOFF_PERIOD);
+	return;
+
+      case C(OFFER, WORSE, OFFER):
+	DFT_LOWER(OP_LOW);
+	MC(0);
+	return;
+
+      case C(BACKOFF, WORSE, OFFER):
+	STATE(WINNER);
+	DFT_STOP;
+      case C(WINNER, WORSE, OFFER):
+	SEND(WINNER);
+	return;
+
+      case C(OFFER, BETTER, WINNER):
+      case C(WINNER, BETTER, WINNER):
+      case C(BACKOFF, BETTER, WINNER):
+      case C(WINNER, BETTER, BACKOFF):
+      case C(BACKOFF, BETTER, BACKOFF):
+	STATE(LOSE);
+	DFT_STOP;
+      case C(LOSE, BETTER, WINNER):
+      case C(LOSE, BETTER, BACKOFF):
+	DF_SENDER;
+	return;
+
+      case C(OFFER, BETTER, BACKOFF):
+	DFT(msg->backoff_interval + OP_LOW);
+	MC(0);
+	return;
+
+      case C(LOSE, WORSE, BACKOFF):
+      case C(LOSE, WORSE, WINNER):
+      case C(WINNER, WORSE, BACKOFF):
+      case C(WINNER, WORSE, WINNER):
+      case C(BACKOFF, WORSE, BACKOFF):
+      case C(BACKOFF, WORSE, WINNER):
+	DF_SENDER;
+	STATE(OFFER);
+	DFT(OP_LOW);
+	MC(0);
+	return;
+
+      case C(LOSE, WORSE, OFFER):
+	if (rpi->rp->upstream == NULL || rpi->rp->upstream == rpi)
+	  /**
+	   * When there is a link with more than one router, but all of them
+	   * without path to RPA, an infinite election occurs. One router wins the
+	   * election, but does not announce itself a winner. That is the same as
+	   * if it died just before winning, resulting in other routers restarting
+	   * the election.
+	   * Do not answering the worse offers, when out metric is infinite, may
+	   * not break the protocol, because the offering metric is also infinite.
+	   * The protocols should fall into such losing misery one by one, until
+	   * the last one loses.
+	   */
+	  break;
+	STATE(OFFER);
+	DFT(OP_LOW);
+	MC(0);
+	return;
+
+      case C(OFFER, WORSE, BACKOFF):
+      case C(OFFER, WORSE, WINNER):
+	DF_SENDER;
+	DFT_LOWER(OP_LOW);
+	MC(0);
+	return;
+
+      case C(OFFER, BETTER, PASS):
+      case C(WINNER, BETTER, PASS):
+      case C(BACKOFF, BETTER, PASS):
+	DFT_STOP;
+      case C(LOSE, BETTER, PASS):
+	DF_TARGET;
+	return;
+
+      case C(OFFER, WORSE, PASS):
+	DF_TARGET;
+	DFT_LOWER(OP_LOW);
+	MC(0);
+	return;
+
+      case C(WINNER, WORSE, PASS):
+      case C(BACKOFF, WORSE, PASS):
+      case C(LOSE, WORSE, PASS):
+	STATE(OFFER);
+	DF_TARGET;
+	DFT(OP_LOW);
+	MC(0);
+	return;
+
+      default:
+	bug("Invalid DF state %u, msg %u with %s metric", rpi->election_state, msg->type, better ? "better" : "worse");
+	return;
+    }
+}
+
+void
+pim_df_timer_expired(timer *t)
+{
+  struct pim_rp_iface *rpi = t->data;
+  struct pim_proto *p = rpi->rp->proto;
+  switch (rpi->election_state)
+  {
+    case PIM_DF_OFFER:
+      if (rpi->mc >= rpi->iface->cf->election_robustness)
+	{
+	  if (rpi->rp->upstream && rpi->rp->upstream != rpi)
+	    {
+	      TRACE(D_EVENTS, "Finished offering: taking over DF on link %s.", rpi->iface->iface->name);
+	      STATE(WINNER);
+	      SEND(WINNER);
+	    }
+	  else
+	    {
+	      TRACE(D_EVENTS, "Finished offering, no upstream: losing.");
+	      STATE(LOSE);
+	      df_set_df(rpi, NULL, PIM_METRIC_INFTY);
+	      DFT_STOP;
+	    }
+	}
+      else
+	{
+	  rpi->mc++;
+	  SEND(OFFER);
+	  DFT(OP_LOW);
+	}
+      break;
+    case PIM_DF_WINNER:
+      if (rpi->mc < rpi->iface->cf->election_robustness)
+	{
+	  rpi->mc++;
+	  SEND(WINNER);
+	  DFT(OP_LOW);
+	}
+      break;
+    case PIM_DF_BACKOFF:
+      STATE(LOSE);
+      SEND_TARGET(PASS, rpi->bo->neigh->addr, rpi->bo_metric);
+      df_set_df(rpi, rpi->bo, rpi->bo_metric);
+      DFT_STOP;
+      df_set_bo(rpi, NULL, PIM_METRIC_INFTY);
+      break;
+    case PIM_DF_LOSE:
+    default:
+      break;
+  }
+}
+
+void
+pim_df_reelect(struct pim_rp_iface *rpi)
+{
+  MC(0);
+  DFT(OP_LOW);
+}
+
+void
+pim_df_metric_changed(struct pim_rp_iface *rpi, struct pim_metric old_metric)
+{
+  struct pim_metric new_metric = pim_get_metric(rpi);
+  switch (rpi->election_state)
+    {
+      case PIM_DF_OFFER:
+      case PIM_DF_WINNER:
+	if (!pim_metric_better(&new_metric, &old_metric, NULL, NULL))
+	  pim_df_reelect(rpi);
+	break;
+      case PIM_DF_BACKOFF:
+      case PIM_DF_LOSE:
+	if (!rpi->df || pim_metric_better(&new_metric, &rpi->df_metric, &rpi->iface->iface->addr->ip, &rpi->df->neigh->addr))
+	  {
+	    df_set_state(rpi, rpi->election_state == PIM_DF_BACKOFF ? PIM_DF_WINNER : PIM_DF_OFFER);
+	    pim_df_reelect(rpi);
+	  }
+
+    }
+}
diff --git a/proto/pim/packets.c b/proto/pim/packets.c
new file mode 100644
index 0000000..9e51564
--- /dev/null
+++ b/proto/pim/packets.c
@@ -0,0 +1,647 @@
+/*
+ *  BIRD -- PIM protocol
+ *
+ *  (c) 2016 Ondrej Hlavaty <aearsis@eideo.cz>
+ *
+ *  Can be freely distributed and used under the terms of the GNU GPL.
+ */
+
+#include "pim.h"
+#include "lib/checksum.h"
+#include "lib/ip.h"
+#include "lib/resource.h"
+
+struct pim_pkt {
+  u8 vers_type;
+  u8 subtype_rsvd;
+  u16 checksum;
+};
+
+struct pim_hello_option {
+    u16 opt_type;
+    u16 opt_len;
+    union {
+	u16 holdtime;
+	u32 gen_id;
+    };
+};
+
+struct pim_jp_group {
+    u16 joined, pruned;
+};
+
+#define PKT_HEADER_SIZE 4
+#define DROP(msg, args...) do { log(L_WARN msg, ## args); return 1; } while(0)
+
+#define PKT_HELLO	    0
+#define PKT_JOIN_PRUNE	    3
+#define PKT_DF             10
+
+#ifndef PARSER
+#define IFA_TRACE(flags, msg, args...) \
+  do { if (ifa->proto->p.debug & flags) log(L_TRACE "%s: " msg, ifa->proto->p.name , ## args ); } while(0)
+#endif
+
+/*
+ * Encoded-Unicast Address decoding
+ */
+static byte *
+pim_decode_unicast(byte *buf, ip_addr *addr)
+{
+  byte af_type = *buf++;
+  byte af_encoding = *buf++;
+  if (af_encoding != 0)
+    return NULL;
+
+  switch (af_type)
+    {
+      case PIM_AFN_IP4:
+	*addr = ipa_from_ip4(get_ip4(buf));
+	return buf + 4;
+      case PIM_AFN_IP6:
+	*addr = ipa_from_ip6(get_ip6(buf));
+	return buf + 16;
+      default:
+	return NULL;
+    }
+}
+
+static byte *
+pim_decode_metric(byte *bbuf, struct pim_metric *metric)
+{
+  u32 *buf = (u32*) bbuf;
+  metric->pref = htonl(*buf++);
+  metric->metric = htonl(*buf++);
+  return (byte *) buf;
+}
+
+/*
+ * Encoded-Group Address decoding
+ */
+static byte *
+pim_decode_group(byte *buf, struct pim_jp_grp *grp)
+{
+  byte af_type = *buf++;
+  byte af_encoding = *buf++;
+  grp->flags = *buf++;
+  if (af_encoding != 0)
+    return NULL;
+  if (af_type == PIM_AFN_IP4)
+  {
+    u8 pxlen = *buf++;
+    ip4_addr prefix = get_ip4(buf);
+    net_fill_ip4(&grp->ga, prefix, pxlen);
+    return buf + 4;
+  }
+  if (af_type == PIM_AFN_IP6)
+  {
+    u8 pxlen = *buf++;
+    ip6_addr prefix = get_ip6(buf);
+    net_fill_ip6(&grp->ga, prefix, pxlen);
+    return buf + 16;
+  }
+  return NULL;
+}
+
+/*
+ * Encoded-Source address decoding
+ */
+static byte *
+pim_decode_source(byte *buf, struct pim_jp_src *src)
+{
+  byte af_type = *buf++;
+  byte af_encoding = *buf++;
+  src->flags = *buf++;
+  if (af_encoding != 0)
+    return NULL;
+  if (af_type == PIM_AFN_IP4)
+  {
+    u8 pxlen = *buf++;
+    ip4_addr prefix = get_ip4(buf);
+    net_fill_ip4(&src->addr, prefix, pxlen);
+    return buf + 4;
+  }
+  if (af_type == PIM_AFN_IP6)
+  {
+    u8 pxlen = *buf++;
+    ip6_addr prefix = get_ip6(buf);
+    net_fill_ip6(&src->addr, prefix, pxlen);
+    return buf + 16;
+  }
+  return NULL;
+}
+
+static char *df_types[] = { "BUG", "OFFER", "WINNER", "BACKOFF", "PASS" };
+
+static int
+pim_rx_df(struct pim_proto *p, struct pim_pkt *pkt, int len, struct pim_neigh *n)
+{
+  struct pim_df_msg msg;
+  msg.sender = n;
+  msg.type = pkt->subtype_rsvd >> 4;
+
+  ASSERT(msg.type <= 4);
+
+  if (!n)
+    DROP("Unknown neighbor!");
+
+  n->flags |= PIM_NF_BIDIR; // Otherwise he wouldn't be sending DF messages
+
+  byte *buf = (void *) pkt + PKT_HEADER_SIZE;
+
+  if ((buf = pim_decode_unicast(buf, &msg.rpa)) == NULL)
+    DROP("Unknown address type and encoding");
+
+  if ((buf = pim_decode_metric(buf, &msg.metric)) == NULL)
+    goto drop;
+
+  TRACE(D_EVENTS, "Received DF %s on %s, RPA %I, metric (%d, %d, %I)",
+      df_types[msg.type], n->iface->iface->name, msg.rpa,
+      msg.metric.pref, msg.metric.metric, n->neigh->addr);
+
+  if (msg.type >= PIM_DF_BACKOFF)
+    {
+      buf = pim_decode_unicast(buf, &msg.target);
+      buf = pim_decode_metric(buf, &msg.target_metric);
+
+      TRACE(D_PACKETS, "\t arg addr %I", msg.target);
+      TRACE(D_PACKETS, "\t arg metric (%lu, %lu)", msg.target_metric.pref, msg.target_metric.metric);
+    }
+
+  if (msg.type == PIM_DF_BACKOFF)
+    {
+      msg.backoff_interval = ntohs(*((u16 *) buf)) MS;
+      TRACE(D_PACKETS, "\t backoff period %u ms", msg.backoff_interval TO_MS);
+      buf += 2;
+    }
+
+  ASSERT(buf == (void *) pkt + len);
+
+  pim_df_accept(n->iface, &msg);
+  return 1;
+
+drop:
+  return 1;
+}
+
+static int
+pim_rx_hello(struct pim_proto *p, struct pim_pkt *pkt, int len, struct pim_neigh *n)
+{
+  u32 gen_id;
+  uint holdtime;
+
+  TRACE(D_PACKETS, "Received HELLO from %I", n->neigh->addr);
+
+  struct pim_hello_option *opt = (void *) pkt + PKT_HEADER_SIZE;
+  struct pim_hello_option *end = (void *) pkt + len;
+  for (; opt < end; opt = (void *) opt + ntohs(opt->opt_len) + 4)
+    {
+      switch (ntohs(opt->opt_type))
+	{
+	  case PIM_HLO_OPT_HOLDTIME:
+	    holdtime = ntohs(opt->holdtime);
+	    if (holdtime == PIM_HOLDTIME_INF)
+	      tm_stop(n->hold);
+	    else
+	      tm_start(n->hold, holdtime);
+	    break;
+	  case PIM_HLO_OPT_GENID:
+	    gen_id = ntohl(opt->gen_id);
+	    if (n->gen_id != gen_id)
+	      {
+		TRACE(D_EVENTS, "Neighbor %I changed generation ID", n->neigh->addr);
+		n->flags |= PIM_NF_NEW;
+	      }
+	    n->gen_id = gen_id;
+	    break;
+	  case PIM_HLO_OPT_BIDIR_CAPABLE:
+	    n->flags |= PIM_NF_BIDIR;
+	    break;
+	}
+    }
+
+  n->flags |= PIM_NF_UP;
+  pim_neigh_update(n);
+
+  return 1;
+}
+
+#define JP_DROP(msg, args...) do { log(L_WARN msg, ## args); goto drop; } while (0)
+
+static int
+pim_rx_jp(struct pim_proto *p, struct pim_pkt *pkt, int len, struct pim_neigh *n)
+{
+  struct pim_jp_msg msg;
+
+  pool *jp_pool = rp_new(p->p.pool, "Join/Prune RX packet (temporary)");
+
+  byte *buf = (byte *) pkt + 4;
+  buf = pim_decode_unicast(buf, &msg.target);
+  if (!buf)
+    JP_DROP("Unkown address format in target.");
+
+  buf++; // Reserved bytes
+  msg.num_groups = *buf++;
+  msg.holdtime = ntohs(*((u16 *) buf)) S;
+  buf += 2;
+
+  struct pim_jp_grp *groups = mb_alloc(jp_pool, sizeof(struct pim_jp_grp) * msg.num_groups);
+  struct pim_jp_grp *grp;
+  for (grp = groups; grp < groups + msg.num_groups; grp++)
+  {
+    buf = pim_decode_group(buf, grp);
+    if (!buf)
+      JP_DROP("Unknown address format in group address.");
+    grp->j_count = ntohs(*(u16 *) buf);
+    buf += 2;
+    grp->p_count = ntohs(*(u16 *) buf);
+    buf += 2;
+    u32 count = (grp->j_count + grp->p_count);
+    struct pim_jp_src *src = mb_alloc(jp_pool, sizeof(struct pim_jp_src) * count);
+    grp->j = src;
+    grp->p = src + grp->j_count;
+    struct pim_jp_src *end = src + count;
+    for (; src != end; src++)
+    {
+      buf = pim_decode_source(buf, src);
+      if (!buf)
+	JP_DROP("Invalid source specified");
+    }
+  }
+
+  if (buf - (byte *) pkt != len)
+    JP_DROP("Unexpected packet length (off by %i)", buf - (byte *) pkt - len);
+
+  for (u8 i = 0; i < msg.num_groups; i++)
+    pim_jp_received(p, &msg, &groups[i], n);
+
+drop:
+  rfree(jp_pool);
+  return 1;
+}
+
+/*
+ * Align the packet to a multiple of 4.
+ */
+static uint
+pkt_pad(struct pim_pkt* pkt, uint len)
+{
+  uint aligned_len = BIRD_ALIGN(len, 4);
+  bzero(((void *) pkt) + len, aligned_len - len);
+  return aligned_len;
+}
+
+static int
+pim_rx_hook(sock *sk, int len)
+{
+  struct pim_pkt *pkt = (struct pim_pkt *) sk_rx_buffer(sk, &len);
+  struct pim_iface *ifa = (struct pim_iface *) sk->data;
+  struct pim_proto *p = ifa->proto;
+
+  if (len < 4)
+    DROP("Packet too short (%d bytes).", len);
+
+  if ((pkt->vers_type >> 4) != 2)
+    DROP("Not a PIMv2 packet (vers %x).", pkt->vers_type >> 4);
+
+  if (!pim_is_ipv6(p))
+    {
+      int aligned_len = pkt_pad(pkt, len);
+      if (!ipsum_verify(pkt, aligned_len, NULL))
+	DROP("Bad checksum.");
+    }
+
+  struct pim_neigh * n = pim_neigh_get(p, &sk->faddr, ifa);
+
+  switch (pkt->vers_type & 0xf)
+    {
+      case PKT_HELLO: /* Hello packet */
+	return pim_rx_hello(p, pkt, len, n);
+      case PKT_JOIN_PRUNE: /* Join/Prune */
+	return pim_rx_jp(p, pkt, len, n);
+      case PKT_DF: /* DF election */
+	return pim_rx_df(p, pkt, len, n);
+      default:
+	DROP("Packet type %d not implemented!", pkt->vers_type & 0xf);
+    }
+
+  return 1;
+}
+
+static void
+pim_err_hook(sock *sk, int err)
+{
+  struct pim_iface *ifa = (struct pim_iface *) (sk->data);
+  struct pim_proto *p = ifa->proto;
+  log(L_ERR "%s: Socket error on %s: %M", p->p.name, ifa->iface->name, err);
+}
+
+static inline void *
+iface_tx_pkt(struct pim_iface *ifa)
+{
+  return (void *) ifa->sk->tbuf;
+}
+
+static inline void *
+iface_tx_buf(struct pim_iface *ifa)
+{
+  return (void *) ifa->sk->tbuf + ifa->pkt_len;
+}
+
+static inline struct pim_hello_option *
+iface_tx_hello_option(struct pim_iface *ifa, int opt_len)
+{
+  struct pim_hello_option * opt = iface_tx_buf(ifa);
+  ifa->pkt_len += 4 + opt_len;
+  opt->opt_len = htons(opt_len);
+  return opt;
+}
+
+/*
+ * The packet is constructed in the buffer, continually adding another sections.
+ * Start by calling pkt_init, then use some encodes, and finish with pkt_send.
+ */
+static inline struct pim_pkt *
+pkt_init(struct pim_iface *ifa, u8 type)
+{
+  struct pim_pkt *pkt = iface_tx_pkt(ifa);
+  pkt->vers_type = (2 << 4) | (type & 0x0f);
+  pkt->subtype_rsvd = 0;
+  ifa->pkt_len = PKT_HEADER_SIZE;
+  return pkt;
+}
+
+static inline void
+pkt_checksum(struct pim_iface *ifa)
+{
+  if (pim_is_ipv6(ifa->proto))
+    return;
+
+  struct pim_pkt *pkt = iface_tx_pkt(ifa);
+  uint aligned_len = pkt_pad(pkt, ifa->pkt_len);
+  pkt->checksum = 0;
+  pkt->checksum = ipsum_calculate(pkt, aligned_len, NULL);
+}
+
+static int
+pkt_send(struct pim_iface *ifa)
+{
+  pkt_checksum(ifa);
+  return sk_send(ifa->sk, ifa->pkt_len);
+}
+
+/*
+ * Send a PIM hello to an interface.
+ */
+int
+pim_send_hello(struct pim_iface *ifa, uint holdtime)
+{
+  IFA_TRACE(D_PACKETS, "Send HELLO to iface %s", ifa->iface->name);
+  pkt_init(ifa, PKT_HELLO);
+
+  struct pim_hello_option *opt = iface_tx_hello_option(ifa, 2);
+  opt->opt_type = htons(PIM_HLO_OPT_HOLDTIME);
+  opt->holdtime = htons(holdtime);
+
+  opt = iface_tx_hello_option(ifa, 4);
+  opt->opt_type = htons(PIM_HLO_OPT_GENID);
+  opt->gen_id = htonl(ifa->gen_id);
+
+  opt = iface_tx_hello_option(ifa, 0);
+  opt->opt_type = htons(PIM_HLO_OPT_BIDIR_CAPABLE);
+
+  ifa->hello_sent = 1;
+
+  return pkt_send(ifa);
+}
+
+/*
+ * Encoded-Unicast address
+ */
+static inline void
+pim_encode_unicast(struct pim_iface *ifa, ip_addr *addr)
+{
+  byte *buf = iface_tx_buf(ifa);
+  *buf++ = ipa_is_ip4(*addr) ? PIM_AFN_IP4 : PIM_AFN_IP6;
+  *buf++ = 0;
+  ifa->pkt_len += 2;
+  if (ipa_is_ip4(*addr))
+    {
+      buf = put_ip4(buf, ipa_to_ip4(*addr));
+      ifa->pkt_len += 4;
+    }
+  else
+    {
+      buf = put_ip6(buf, ipa_to_ip6(*addr));
+      ifa->pkt_len += 16;
+    }
+}
+
+/*
+ * Encoded-Group address
+ */
+static inline void
+pim_encode_group(struct pim_iface *ifa, ip_addr *addr, u8 flags)
+{
+  u8 *buf = iface_tx_buf(ifa);
+  *buf++ = ipa_is_ip4(*addr) ? PIM_AFN_IP4 : PIM_AFN_IP6;
+  *buf++ = 0;
+  *buf++ = flags;
+  if (ipa_is_ip4(*addr))
+    {
+      *buf++ = IP4_MAX_PREFIX_LENGTH;
+      buf = put_ip4(buf, ipa_to_ip4(*addr));
+      ifa->pkt_len += 8;
+    }
+  else
+    {
+      *buf++ = IP6_MAX_PREFIX_LENGTH;
+      buf = put_ip6(buf, ipa_to_ip6(*addr));
+      ifa->pkt_len += 20;
+    }
+}
+
+/*
+ * Encoded-Source address
+ */
+static void
+pim_encode_source(struct pim_iface *ifa, ip_addr *prefix, u8 flags)
+{
+  pim_encode_group(ifa, prefix, flags & 7);
+}
+
+static inline void
+pim_encode_metric(struct pim_iface *ifa, struct pim_metric *metric)
+{
+  u32 *buf = iface_tx_buf(ifa);
+  *buf++ = htonl(metric->pref);
+  *buf++ = htonl(metric->metric);
+  ifa->pkt_len += 8;
+}
+
+/*
+ * Send any DF message to any interface with respect to a RP.
+ */
+int
+pim_send_df(struct pim_rp_iface *rpi, struct pim_df_msg *msg)
+{
+  struct pim_iface *ifa = rpi->iface;
+  IFA_TRACE(D_EVENTS, "Send DF %s to iface %s, RPA %I, metric (%d, %d, %I)",
+      df_types[msg->type], ifa->iface->name, msg->rpa,
+      msg->metric.pref, msg->metric.metric, ifa->iface->addr->ip);
+
+  struct pim_pkt *pkt = pkt_init(ifa, PKT_DF);
+  pkt->subtype_rsvd = msg->type << 4;
+
+  pim_encode_unicast(ifa, &msg->rpa);
+  pim_encode_metric(ifa, &msg->metric);
+
+  /* Backoff and Pass messages have a target */
+  if (msg->type >= PIM_DF_BACKOFF)
+    {
+      pim_encode_unicast(ifa, &msg->target);
+      pim_encode_metric(ifa, &msg->target_metric);
+      if (msg->type == PIM_DF_BACKOFF)
+	{
+	  u16 *buf = iface_tx_buf(ifa);
+	  *buf = htons(msg->backoff_interval TO_MS);
+	  ifa->pkt_len += 2;
+	}
+    }
+  return pkt_send(ifa);
+}
+
+/*
+ * Construct a header for a Join/Prune message
+ */
+static struct pim_pkt *
+pim_jp_header(struct pim_iface *ifa, ip_addr *up_addr, u16 holdtime)
+{
+  struct pim_pkt *pkt = pkt_init(ifa, 3);
+  pim_encode_unicast(ifa, up_addr);
+  u16 *buf = iface_tx_buf(ifa);
+  *buf++ = 0; // reserved + group count
+  *buf++ = htons(holdtime);
+  ifa->group_count_offset = ifa->pkt_len + 1;
+  ifa->pkt_len += 4;
+  return pkt;
+}
+
+/*
+ * Add a group to a packet being constructed
+ */
+static struct pim_jp_group *
+pim_jp_group(struct pim_iface *ifa, struct pim_grp *grp)
+{
+  char *pkt = iface_tx_pkt(ifa);
+  pkt[ifa->group_count_offset]++;
+
+  pim_encode_group(ifa, &grp->ga, PIM_JP_BIDIR);
+
+  struct pim_jp_group *group = iface_tx_buf(ifa);
+  group->joined = 0;
+  group->pruned = 0;
+  ifa->pkt_len += 4;
+
+  return group;
+}
+
+/*
+ * Add a wildcard source joined/pruned for a group.
+ */
+void
+pim_jp_wildcard(struct pim_iface *ifa, struct pim_jp_group *group, ip_addr *rpa, int join)
+{
+  if (join && group->pruned)
+    bug("Tried to join source after pruning one (while constructing tx join/prune packet)");
+
+  pim_encode_source(ifa, rpa, PIM_JP_WILDCARD | PIM_JP_RPT);
+
+  if (join)
+    group->joined = htons(ntohs(group->joined) + 1);
+  else
+    group->pruned = htons(ntohs(group->pruned) + 1);
+}
+
+/*
+ * For a specified RP, send a Join/Prune for all groups to a target.
+ * Used when the DF changes.
+ */
+int
+pim_send_jp_all(struct pim_rp *rp, struct pim_neigh *target, int join)
+{
+  struct pim_proto *p = rp->proto;
+  TRACE(D_PACKETS, "Sending all %s for RP %I:", join ? "joins" : "prunes", rp->rpa);
+
+  struct pim_iface *pif = target->iface;
+  pim_need_hello(pif);
+
+  pim_jp_header(pif, &target->neigh->addr, pif->cf->jp_holdtime TO_S);
+
+  struct pim_grp *grp;
+  WALK_LIST(grp, rp->groups)
+    {
+      struct pim_jp_group *group = pim_jp_group(pif, grp);
+      pim_jp_wildcard(pif, group, &rp->rpa, join);
+      TRACE(D_PACKETS, "\t%I", grp->ga);
+    }
+
+  return pkt_send(pif);
+}
+
+/*
+ * Send a Join/Prune package on an interface to a target.
+ * Is used even for sending packets targeted to ourselves.
+ */
+int
+pim_tx_jp(struct pim_iface *pif, ip_addr *target, struct pim_grp *grp, int join)
+{
+  struct pim_proto *p = grp->proto;
+  TRACE(D_PACKETS, "Sending %s(*, %I) to %I, holdtime %u",
+      join ? "Join" : "Prune", grp->ga, *target,
+      pif->cf->jp_holdtime TO_S);
+
+  pim_jp_header(pif, target, pif->cf->jp_holdtime TO_S);
+  struct pim_jp_group *group = pim_jp_group(pif, grp);
+  pim_jp_wildcard(pif, group, &grp->rpa, join);
+  return pkt_send(pif);
+}
+
+int
+pim_sk_open(struct pim_iface *ifa)
+{
+  sock *sk = sk_new(ifa->proto->p.pool);
+  sk->type = SK_IP;
+  sk->dport = PIM_PROTO;
+  sk->saddr = ifa->iface->addr->ip;
+  sk->iface = ifa->iface;
+
+  sk->data = ifa;
+  sk->daddr = pim_is_ipv6(ifa->proto) ? IP6_PIM_ROUTERS : IP4_PIM_ROUTERS;
+  sk->ttl = 1;
+  sk->rx_hook = pim_rx_hook;
+  sk->err_hook = pim_err_hook;
+
+  sk_set_tbsize(sk, 1024);
+  sk_set_rbsize(sk, 1024);
+
+  if (pim_is_ipv6(ifa->proto))
+    if (sk_set_ipv6_checksum(sk, 16) < 0)
+      goto err;
+
+  if (sk_open(sk) < 0)
+    goto err;
+
+  if (sk_setup_multicast(sk) < 0)
+    goto err;
+
+  if (sk_join_group(sk, sk->daddr) < 0)
+    goto err;
+
+  ifa->sk = sk;
+  return 1;
+err:
+  log(L_ERR "%s: Socket error: %s%#m", ifa->proto->p.name, sk->err);
+  rfree(sk);
+  return 0;
+}
diff --git a/proto/pim/pim.c b/proto/pim/pim.c
new file mode 100644
index 0000000..7b9d702
--- /dev/null
+++ b/proto/pim/pim.c
@@ -0,0 +1,1281 @@
+/*
+ *  BIRD -- PIM protocol
+ *
+ *  (c) 2016 Ondrej Hlavaty <aearsis@eideo.cz>
+ *
+ *  Can be freely distributed and used under the terms of the GNU GPL.
+ */
+
+/*
+ * DOC: Protocol Independent Multicast (PIM)
+ *
+ * This protocol implements Bidirectional PIM, a variant of PIM-SM that builds
+ * bidirectional shared trees connecting multicast sources and receivers.
+ * Bidirectional trees are built using a fail-safe Designated Forwarder (DF)
+ * election mechanism operating on each link of a multicast topology. With
+ * the assistance of the DF, multicast data is natively forwarded from sources
+ * to the Rendezvous-Point (RP) and hence along the shared tree to receivers
+ * without requiring source-specific state.  The DF election takes place at RP
+ * discovery time and provides the route to the RP, thus eliminating
+ * the requirement for data-driven protocol events.
+ *
+ * Its implementation is split into three files, |packets.c| handling low-level
+ * packet formats and |pim.c| implementing BIRD interface and protocol logic.
+ * |df.c| contains code associated with DF election (many cases).
+ *
+ * We can split the implementation into three logical units. First, the DF
+ * logic, ensures there is exactly one DF elected on every interface. Its
+ * majority is in the |df.c| source file. Then there is the Join/Prune
+ * mechanism, shared with other versions of PIM. It listens for downstream
+ * requests, and pushes them to the BIRD's multicast request table. Also, it
+ * sends joins upstream when appropriate. Last, there is the forwarding logic.
+ * It is fairly simple - whenever there is a request for a group and interface,
+ * and we are the DF on that interface, forward the group there.
+ */
+
+#include <linux/rtnetlink.h>
+
+#include "pim.h"
+#include "filter/filter.h"
+#include "lib/ip.h"
+#include "lib/event.h"
+#include "nest/route.h"
+
+#define HASH_RP_KEY(n)		n->rpa
+#define HASH_RP_NEXT(n)		n->next
+#define HASH_RP_EQ(a,b)		ipa_equal(a,b)
+#define HASH_RP_FN(k)		ip6_hash(k)
+
+#define HASH_GRP_KEY(n)		n->ga
+#define HASH_GRP_NEXT(n)	n->next
+#define HASH_GRP_EQ(a,b)	ipa_equal(a,b)
+#define HASH_GRP_FN(k)		ip6_hash(k)
+
+#define HASH_RPI_KEY(n)			n->rp->rpa, n->iface->iface->index
+#define HASH_RPI_NEXT(n)		n->next
+#define HASH_RPI_EQ(rpa, ifa, rpb, ifb)	ipa_equal(rpa, rpb) && ifa == ifb
+#define HASH_RPI_FN(rpa, ix)		(ip6_hash(rpa) ^ ix)
+
+/******************************************************************************
+                                Neighbor management
+ ******************************************************************************/
+
+static void
+pim_neigh_expired(timer *tm)
+{
+  struct pim_neigh *n = tm->data;
+  n->flags &= ~PIM_NF_UP;
+  pim_neigh_update(n);
+}
+
+static struct pim_neigh *
+pim_neigh_new(struct pim_iface *ifa, neighbor *n)
+{
+  struct pim_proto *p = ifa->proto;
+  struct pim_neigh *pn = mb_allocz(p->p.pool, sizeof(struct pim_neigh));
+  TRACE(D_EVENTS, "New neighbor %I", n->addr);
+  add_tail(&ifa->neigh_list, NODE pn);
+
+  pn->neigh = n;
+  pn->iface = ifa;
+
+  pn->hold = tm_new_set(p->p.pool, pim_neigh_expired, pn, 0, 0);
+  pn->flags = PIM_NF_NEW;
+
+  init_list(&pn->df_list);
+  init_list(&pn->bo_list);
+  tm_start(pn->hold, PIM_HOLDTIME_DEF);
+  n->data = pn;
+  return pn;
+}
+
+struct pim_neigh *
+pim_neigh_from_neighbor(neighbor* n)
+{
+  if (!n)
+    return NULL;
+
+  return (struct pim_neigh *) n->data;
+}
+
+struct pim_neigh *
+pim_neigh_find(struct pim_proto *p, ip_addr *a, struct pim_iface *ifa)
+{
+  neighbor *n = neigh_find2(&p->p, a, ifa->iface, 0);
+  return pim_neigh_from_neighbor(n);
+}
+
+struct pim_neigh *
+pim_neigh_get(struct pim_proto *p, ip_addr *a, struct pim_iface *ifa)
+{
+  neighbor *n = neigh_find2(&p->p, a, ifa->iface, 0);
+  return pim_neigh_from_neighbor(n) ? : pim_neigh_new(ifa, n);
+}
+
+/******************************************************************************
+                                RPA state management
+ ******************************************************************************/
+
+struct pim_rp_iface *
+pim_rp_iface_new(struct pim_rp *rp, struct pim_iface *ifa)
+{
+  struct pim_proto *p = rp->proto;
+  TRACE(D_EVENTS, "New RP iface state (%I, %s)", rp->rpa, ifa->iface->name);
+  struct pim_rp_iface *rpi = mb_allocz(rp->proto->p.pool, sizeof(struct pim_rp_iface));
+  rpi->rp = rp;
+  rpi->iface = ifa;
+
+  HASH_INSERT(rp->proto->rpi_states, HASH_RPI, rpi);
+  add_tail(&rp->iface_list, NODE rpi);
+
+  rpi->df = NULL;
+  rpi->df_metric = PIM_METRIC_INFTY;
+
+  rpi->election_state = PIM_DF_OFFER;
+  rpi->election_timer = tm_new_set(rp->proto->p.pool, pim_df_timer_expired, rpi, 0, 0);
+
+  pim_df_reelect(rpi);
+
+  return rpi;
+}
+
+void
+pim_rp_iface_free(struct pim_rp_iface *rpi)
+{
+  struct pim_rp *rp = rpi->rp;
+  struct pim_proto *p = rp->proto;
+
+  if (rpi == rp->upstream)
+    {
+      rp->upstream = NULL;
+      ev_schedule(p->rpf_update);
+    }
+
+  rfree(rpi->election_timer);
+
+  HASH_REMOVE(p->rpi_states, HASH_RPI, rpi);
+  rem_node(NODE rpi);
+  if (NODE_VALID(&rpi->df_node))
+    rem_node(&rpi->df_node);
+  if (NODE_VALID(&rpi->bo_node))
+    rem_node(&rpi->bo_node);
+  mb_free(rpi);
+}
+
+static inline struct pim_rp_iface *
+pim_rp_iface_find2(struct pim_proto *p, ip_addr rpa, unsigned ifindex)
+{
+  return HASH_FIND(p->rpi_states, HASH_RPI, rpa, ifindex);
+}
+
+struct pim_rp_iface *
+pim_rp_iface_find(struct pim_rp *rp, struct iface *iface)
+{
+  return pim_rp_iface_find2(rp->proto, rp->rpa, iface->index);
+}
+
+static inline struct pim_rp_iface *
+pim_rp_iface_get(struct pim_proto *p, ip_addr rpa, struct iface *iface)
+{
+  struct pim_rp_iface *rpi;
+  if ((rpi = pim_rp_iface_find2(p, rpa, iface->index)))
+    return rpi;
+
+  struct pim_iface *ifa = pim_iface_find(p, iface);
+  if (!ifa)
+    return NULL; /* Cannot get rpi for non-existent iface */
+
+  return pim_rp_iface_new(pim_rp_get(p, &rpa), ifa);
+}
+
+/*
+ * The DF on upstream link has changed from old to new. If possible, send
+ * prunes to the old DF, and joins to the new one.
+ */
+void
+pim_upstream_neighbor_change(struct pim_rp *rp, struct pim_neigh *old, struct pim_neigh *new)
+{
+  struct pim_proto *p = rp->proto;
+
+  TRACE(D_EVENTS, "Upstream neighbor for %I changed.", rp->rpa);
+  if (old) pim_send_jp_all(rp, old, 0);
+  if (new)
+    {
+      pim_send_jp_all(rp, new, 1);
+
+      struct pim_grp *grp;
+      WALK_LIST(grp, rp->groups)
+	{
+	  grp->jt->recurrent = new->iface->cf->jp_periodic TO_S;
+	  tm_start(grp->jt, grp->jt->recurrent);
+	}
+    }
+
+  pim_rp_update_routing(rp);
+}
+
+/*
+ * Callback which is called from within rt_route. The route rt is the best one
+ * for given RP, indicating our upstream and metric.
+ */
+static void
+pim_rp_set_rpf(struct proto *P, void *data, rte* rt)
+{
+  struct pim_rp *rp = data;
+  struct pim_proto *p = (struct pim_proto *) P;
+  TRACE(D_EVENTS, "Setting RPF on %I to %s", rp->rpa, rt->attrs->iface->name);
+
+  struct pim_rp_iface *old_upstream = rp->upstream;
+  struct pim_metric old_metric = rp->rp_metric;
+
+  if (!old_upstream || old_upstream->iface->iface != rt->attrs->iface)
+    rp->upstream = pim_rp_iface_get(p, rp->rpa, rt->attrs->iface);
+
+  if (rp->upstream == NULL)
+    {
+      /* When an interface is already deleted in PIM, but not yet in other
+       * protocols, routes may still exist. Reschedule the event and try again later.
+       */
+      ev_schedule(p->rpf_update);
+      return;
+    }
+
+  rp->rp_metric.pref = rt->pref;
+  rp->rp_metric.metric = rt_get_igp_metric(rt);
+
+  if (old_upstream != rp->upstream)
+    {
+      pim_upstream_neighbor_change(rp,
+	old_upstream ? old_upstream->df : NULL,
+	rp->upstream ? rp->upstream->df : NULL);
+    }
+
+  struct pim_rp_iface *rpi;
+  WALK_LIST(rpi, rp->iface_list)
+    pim_df_metric_changed(rpi, (rpi == old_upstream)
+      ? PIM_METRIC_INFTY : old_metric);
+}
+
+/*
+ * Ask the MRIB what the interface and metric towards RPA is.
+ */
+static void
+pim_rp_fill_rpf(struct pim_rp *rp)
+{
+  net_addr n;
+  net_fill_ip_host(&n, rp->rpa);
+  rt_route(rp->proto->mrib_channel, &n, pim_rp_set_rpf, rp);
+}
+
+
+struct pim_rp *
+pim_rp_new(struct pim_proto *p, ip_addr *rpa)
+{
+  TRACE(D_EVENTS, "New RP state %I", *rpa);
+  struct pim_rp *rp = mb_allocz(p->p.pool, sizeof(struct pim_rp));
+  rp->rpa = *rpa;
+  HASH_INSERT(p->rp_states, HASH_RP, rp);
+
+  net_addr_ip4 net;
+  net_fill_ip_host((net_addr *) &net, *rpa);
+
+  trie_add_prefix(p->rp_trie, (net_addr *) &net, 0, net.pxlen);
+
+  rp->proto = p;
+  rp->upstream = NULL;
+  rp->rp_metric = PIM_METRIC_INFTY;
+
+  init_list(&rp->iface_list);
+  init_list(&rp->groups);
+
+  struct pim_iface *ifa;
+  WALK_LIST(ifa, p->iface_list)
+      pim_rp_iface_new(rp, ifa);
+
+  pim_rp_fill_rpf(rp);
+
+  return rp;
+}
+
+struct pim_rp *
+pim_rp_find(struct pim_proto *p, ip_addr *rpa)
+{
+  return HASH_FIND(p->rp_states, HASH_RP, *rpa);
+}
+
+struct pim_rp *
+pim_rp_get(struct pim_proto *p, ip_addr *rpa)
+{
+  return pim_rp_find(p, rpa) ? : pim_rp_new(p, rpa);
+}
+
+/******************************************************************************
+                                Group state management
+ ******************************************************************************/
+
+static void pim_request_join(struct pim_grp_iface *grpi, int join);
+
+static void
+pim_grp_iface_expire(timer *et)
+{
+  struct pim_grp_iface *grpi = et->data;
+  pim_request_join(grpi, 0);
+}
+
+static void
+pim_grp_iface_prune_expire(timer *et)
+{
+  struct pim_grp_iface *grpi = et->data;
+  struct pim_proto *p = grpi->grp->proto;
+  TRACE(D_EVENTS, "Prune pending time for (%I, %s) expired.", grpi->grp->ga, grpi->iface->iface->name);
+  pim_send_jp(grpi->iface, grpi->grp, 0);
+  pim_request_join(grpi, 0);
+}
+
+static struct pim_grp_iface *
+pim_grp_iface_new(struct pim_grp *grp, struct pim_iface *ifa)
+{
+  struct pim_grp_iface *gi = mb_allocz(grp->proto->p.pool, sizeof(struct pim_grp_iface));
+  add_tail(&grp->iface_list, NODE gi);
+  add_tail(&ifa->grp_list, &gi->iface_node);
+  gi->iface = ifa;
+  gi->grp = grp;
+
+  struct pim_proto *p = grp->proto;
+  TRACE(D_EVENTS, "New grp_iface (%I, %s)", grp->ga, ifa->iface->name);
+
+  gi->et = tm_new_set(grp->proto->p.pool, pim_grp_iface_expire, gi, 0, 0);
+  gi->ppt = tm_new_set(grp->proto->p.pool, pim_grp_iface_prune_expire, gi, 0, 0);
+  return gi;
+}
+
+struct pim_grp_iface *
+pim_grp_iface_find(struct pim_grp *grp, struct pim_iface *ifa)
+{
+  struct pim_grp_iface *grpi;
+  WALK_LIST(grpi, grp->iface_list)
+    if (grpi->iface == ifa)
+	return grpi;
+  return NULL;
+}
+
+struct pim_grp_iface *
+pim_grp_iface_get(struct pim_grp *grp, struct pim_iface *ifa)
+{
+  return pim_grp_iface_find(grp, ifa) ? : pim_grp_iface_new(grp, ifa);
+}
+
+static void
+pim_grp_iface_free(struct pim_grp_iface *grpi)
+{
+  rfree(grpi->et);
+  rfree(grpi->ppt);
+  rem_node(NODE grpi);
+  rem_node(&grpi->iface_node);
+  mb_free(grpi);
+}
+
+/*
+ * Add/remove the multicast request.
+ */
+static void
+pim_request_join(struct pim_grp_iface *grpi, int join)
+{
+  struct pim_proto *p = grpi->grp->proto;
+  net_addr_union addr;
+  net_fill_mreq((net_addr *) &addr, grpi->grp->ga, grpi->iface->iface->index);
+  net *n = net_get(p->mreq_channel->table, (net_addr *) &addr);
+
+  if (join)
+    {
+      rta a0 = {
+	.src = p->p.main_source,
+	.source = RTS_PIM,
+	.dest = RTD_MREQUEST,
+	.iface = grpi->iface->iface,
+      };
+      rta *a = rta_lookup(&a0);
+      rte *e = rte_get_temp(a);
+
+      e->net = n;
+      rte_update2(p->mreq_channel, (net_addr *) &addr, e, p->p.main_source);
+    }
+  else
+    {
+      rte_update2(p->mreq_channel, (net_addr *) &addr, NULL, p->p.main_source);
+      pim_grp_iface_free(grpi);
+    }
+}
+
+static void
+pim_grp_free(struct pim_grp *grp)
+{
+  struct pim_grp_iface *grpi, *grpi_next;
+  struct pim_joined_iface *ji, *ji_next;
+  WALK_LIST_DELSAFE(grpi, grpi_next, grp->iface_list)
+    {
+      pim_grp_iface_free(grpi);
+    }
+
+  WALK_LIST_DELSAFE(ji, ji_next, grp->joined)
+    {
+      rem_node(NODE ji);
+      mb_free(ji);
+    }
+
+  rfree(grp->jt);
+  HASH_REMOVE(grp->proto->grp_states, HASH_GRP, grp);
+  if (grp->rp)
+    rem_node(NODE grp);
+  mb_free(grp);
+}
+
+static void
+pim_grp_upstream_expire(timer *t)
+{
+  struct pim_grp *grp = t->data;
+  pim_send_upstream_jp(grp);
+  if (EMPTY_LIST(grp->joined))
+    pim_grp_free(grp);
+}
+
+struct pim_grp *
+pim_grp_find(struct pim_proto *p, ip_addr *ga)
+{
+  return HASH_FIND(p->grp_states, HASH_GRP, *ga);
+}
+
+static ip_addr
+pim_grp_find_rpa(struct pim_proto *p, ip_addr *ga)
+{
+  struct net_addr n;
+  struct pim_grp_rpa *gr;
+
+  net_fill_ip_host(&n, *ga);
+  gr = fib_route(&p->groups, &n);
+  if (gr)
+    return gr->rpa;
+  return IPA_NONE;
+}
+
+static struct pim_grp *
+pim_grp_new(struct pim_proto *p, ip_addr *ga)
+{
+  TRACE(D_EVENTS, "New group state %I", *ga);
+  struct pim_grp *grp = mb_allocz(p->p.pool, sizeof(struct pim_grp));
+  grp->ga = *ga;
+  HASH_INSERT(p->grp_states, HASH_GRP, grp);
+
+  grp->proto = p;
+  init_list(&grp->joined);
+  init_list(&grp->iface_list);
+  grp->rpa = pim_grp_find_rpa(p, ga);
+  /* RP may still be unknown. If we are lucky we can find the RPA in a Join
+   * packet. */
+  if (!ipa_zero(grp->rpa))
+    {
+      grp->rp = pim_rp_get(p, &grp->rpa);
+      add_tail(&grp->rp->groups, NODE grp);
+    }
+  grp->jt = tm_new_set(p->p.pool, pim_grp_upstream_expire, grp, 0, PIM_DEFAULT_JP_PERIODIC TO_S);
+
+  return grp;
+}
+
+struct pim_grp *
+pim_grp_get(struct pim_proto *p, ip_addr *ga)
+{
+  return pim_grp_find(p, ga) ?: pim_grp_new(p, ga);
+}
+
+/******************************************************************************
+                                Iface management
+ ******************************************************************************/
+
+static void
+pim_hello_hook(timer *tm)
+{
+  struct pim_iface *ifa = (struct pim_iface *) tm->data;
+  pim_send_hello(ifa, ifa->cf->hello_holdtime TO_S);
+}
+
+void
+pim_need_hello(struct pim_iface *pif)
+{
+  if (!pif->hello_sent)
+    {
+      pim_send_hello(pif, pif->cf->hello_holdtime TO_S);
+      tm_start_btime(pif->hello_timer, pif->cf->hello_int);
+    }
+}
+
+static inline int
+pim_iface_is_up(struct pim_iface *ifa)
+{
+  return !!ifa->sk;
+}
+
+static void
+pim_iface_add(struct object_lock *lock)
+{
+  struct pim_iface *ifa  = lock->data;
+  struct pim_proto *p = ifa->proto;
+
+  if (pim_iface_is_up(ifa))
+    return;
+
+  if (!pim_sk_open(ifa))
+    {
+      log(L_ERR "Failed opening socket");
+      return;
+    }
+
+  ifa->hello_timer->randomize = ifa->cf->hello_dly TO_S;
+  tm_start(ifa->hello_timer, 0);
+  ifa->hello_timer->randomize = 0;
+
+  HASH_WALK(ifa->proto->rp_states, next, rp)
+      pim_rp_iface_new(rp, ifa);
+  HASH_WALK_END;
+
+  TRACE(D_EVENTS, "Iface %s is UP and RUNNING!", ifa->iface->name);
+}
+
+static struct pim_iface *
+pim_iface_new(struct pim_proto *p, struct iface *iface, struct pim_iface_config *ic)
+{
+  TRACE(D_EVENTS, "New iface %s", iface->name);
+  struct pim_iface *ifa = mb_allocz(p->p.pool, sizeof(struct pim_iface));
+  add_tail(&p->iface_list, NODE ifa);
+  ifa->iface = iface;
+  ifa->cf = ic;
+  ifa->proto = p;
+  ifa->gen_id = random_u32();
+  init_list(&ifa->neigh_list);
+  init_list(&ifa->grp_list);
+
+  ifa->hello_timer = tm_new_set(p->p.pool, pim_hello_hook, ifa, ic->hello_dly TO_S, ic->hello_int TO_S);
+
+  struct object_lock *lock = olock_new(p->p.pool);
+  lock->addr = pim_is_ipv6(p) ? IPA_NONE : ipa_from_ip4(net4_prefix(&iface->addr->prefix));
+  lock->type = OBJLOCK_IP;
+  lock->port = PIM_PROTO;
+  lock->inst = ifa->gen_id;
+  lock->iface = iface;
+  lock->data = ifa;
+  lock->hook = pim_iface_add;
+  ifa->lock = lock;
+
+  olock_acquire(lock);
+
+  return ifa;
+}
+
+static int
+pim_iface_down(struct pim_iface *ifa)
+{
+  if (!pim_iface_is_up(ifa))
+    return 0;
+
+  tm_stop(ifa->hello_timer);
+  rfree(ifa->sk);
+  ifa->sk = NULL;
+  return 0;
+}
+
+static int
+pim_iface_free(struct pim_iface* ifa)
+{
+  struct pim_proto *p = ifa->proto;
+  node *n, *next;
+
+  WALK_LIST_DELSAFE(n, next, ifa->grp_list)
+    pim_grp_iface_free(SKIP_BACK(struct pim_grp_iface, iface_node, n));
+
+  HASH_WALK_DELSAFE(p->rp_states, next, rp)
+    {
+      struct pim_rp_iface *rpi = pim_rp_iface_find(rp, ifa->iface);
+      if (rpi)
+	pim_rp_iface_free(rpi);
+    }
+  HASH_WALK_END;
+
+  rem_node(NODE ifa);
+  mb_free(ifa);
+  return 0;
+}
+
+static void
+pim_iface_dump(struct pim_iface *ifa)
+{
+  debug("\tInterface %s, %s, holdtime %u, gen ID %lu\n", ifa->iface->name,
+    pim_iface_is_up(ifa) ? "up" : "down", ifa->cf->hello_holdtime TO_S,
+    ifa->gen_id);
+
+  struct pim_neigh *n;
+  WALK_LIST(n, ifa->neigh_list)
+    debug("\t\tNeighbor %I%s%s\n",
+      n->neigh->addr,
+      (n->flags & PIM_NF_UP) ? " UP" : "",
+      (n->flags & PIM_NF_BIDIR) ? " BIDIR" : ""
+    );
+}
+
+struct pim_iface *
+pim_iface_find(struct pim_proto *p, struct iface * ifa)
+{
+  struct pim_iface * pif;
+  WALK_LIST(pif, p->iface_list)
+    if (pif->iface == ifa)
+      return pif;
+
+  return NULL;
+}
+
+struct pim_iface *
+pim_iface_find_by_index(struct pim_proto *p, unsigned ifindex)
+{
+  struct pim_iface * pif;
+  WALK_LIST(pif, p->iface_list)
+    if (pif->iface->index == ifindex)
+      return pif;
+
+  return NULL;
+}
+
+void
+pim_iface_config_init(struct pim_iface_config * ifc)
+{
+  init_list(&ifc->i.ipn_list);
+
+  ifc->hello_int = PIM_DEFAULT_HELLO_INT;
+  ifc->hello_dly = PIM_DEFAULT_HELLO_DLY;
+  ifc->election_robustness = PIM_DEFAULT_ELECTION_ROBUSTNESS;
+  ifc->override_interval = PIM_DEFAULT_OVERRIDE_INTERVAL;
+  ifc->jp_periodic = PIM_DEFAULT_JP_PERIODIC;
+  ifc->hello_holdtime = -1; /* Computed from hello_int in pim_iface_config_finish() */
+  ifc->jp_holdtime = -1; /* Computed from periodic */
+}
+
+void
+pim_config_init(struct pim_config *cf)
+{
+   init_list(&cf->grp_list);
+   init_list(&cf->patt_list);
+   pim_iface_config_init(&cf->default_iface_cf);
+   pim_iface_config_finish(&cf->default_iface_cf);
+}
+
+void
+pim_iface_config_finish(struct pim_iface_config * ifc)
+{
+  if (ifc->hello_holdtime == -1)
+    ifc->hello_holdtime = (ifc->hello_int * 4) - (ifc->hello_int / 2); // 3.5 * hello_int
+  if (ifc->jp_holdtime == -1)
+    ifc->jp_holdtime = (ifc->jp_periodic * 4) - (ifc->jp_periodic / 2);
+}
+
+static struct channel_config *
+pim_default_channel(struct proto_config *c, uint net_type)
+{
+  if (NULL == proto_cf_find_channel(c, net_type))
+    return channel_config_new(NULL, net_type, c);
+  return NULL;
+}
+
+void
+pim_config_finish(struct pim_config *cf)
+{
+  struct proto_config *c = &cf->c;
+  int v4 = c->net_type != NET_IP6;
+
+  cf->use_ipv6 = !v4;
+
+  // XXX: three times going through a list
+  struct channel_config *cc;
+  pim_default_channel(c, v4 ? NET_IP4 : NET_IP6);
+  if (cc = pim_default_channel(c, v4 ? NET_MREQ4 : NET_MREQ6))
+    cc->out_filter = FILTER_ACCEPT;
+  pim_default_channel(c, v4 ? NET_MGRP4 : NET_MGRP6);
+}
+
+/******************************************************************************
+				Others
+ ******************************************************************************/
+
+/*
+ * Publish a new route for (*,G). Because we do not always have the upstream
+ * state (deleting the route), accept an address and RP instead.
+ */
+static void
+pim_rt_update(struct pim_proto *p, ip_addr *ga, struct pim_rp *rp)
+{
+  net_addr_union addr;
+  net_fill_mgrp((net_addr *) &addr, *ga);
+  net *n = net_get(p->mroute_channel->table, (net_addr *) &addr);
+
+  if (rp && rp->upstream)
+    {
+      rta a0 = {
+	.src = p->p.main_source,
+	.source = RTS_PIM,
+	.dest = RTD_MULTICAST,
+      };
+      rta *a = rta_lookup(&a0);
+      rte *e = rte_get_temp(a);
+
+      e->net = n;
+
+      RTE_MGRP_CLRALL(e->u.mkrt.iifs);
+      RTE_MGRP_CLRALL(e->u.mkrt.oifs);
+
+      /* If known, forward the group upstream */
+      if (rp->upstream)
+	{
+	  RTE_MGRP_SET(rp->upstream->iface->iface, e->u.mkrt.iifs);
+	  RTE_MGRP_SET(rp->upstream->iface->iface, e->u.mkrt.oifs);
+	}
+
+      /* Forward from interface iff we are the DF */
+      struct pim_rp_iface *rpi;
+      WALK_LIST(rpi, rp->iface_list)
+	if (RPI_IS_DF(rpi))
+	  RTE_MGRP_SET(rpi->iface->iface, e->u.mkrt.iifs);
+
+      /* Forward to interface iff we are the DF and there are requests for it */
+      struct pim_grp *grp = pim_grp_find(p, ga);
+      struct pim_joined_iface *j;
+      if (grp)
+	WALK_LIST(j, grp->joined)
+	  if (RPI_IS_DF(pim_rp_iface_get(p, rp->rpa, j->iface)))
+	    RTE_MGRP_SET(j->iface, e->u.mkrt.oifs);
+
+      /* Force the route to be reloaded in all protocols. */
+      /* XXX: This was necessary, but I have forgotten why. */
+      rte_update2(p->mroute_channel, (net_addr *) &addr, NULL, p->p.main_source);
+      rte_update2(p->mroute_channel, (net_addr *) &addr, e, p->p.main_source);
+    }
+  else
+    {
+      rte_update2(p->mroute_channel, (net_addr *) &addr, NULL, p->p.main_source);
+    }
+}
+
+/*
+ * After a change of the RP tree, publish changes to the routing table.
+ */
+void
+pim_rp_update_routing(struct pim_rp *rp)
+{
+  struct pim_proto *p = rp->proto;
+  struct pim_grp *grp;
+
+  WALK_LIST(grp, rp->groups)
+    pim_rt_update(p, &grp->ga, rp);
+}
+/*
+ * Send a Join/Prune packet for a group to an interface.
+ */
+int
+pim_send_jp(struct pim_iface *pif, struct pim_grp *grp, int join)
+{
+  struct pim_proto *p = grp->proto;
+
+  struct pim_rp_iface *rpi = pim_rp_iface_get(p, grp->rpa, pif->iface);
+
+  pim_need_hello(pif);
+
+  ip_addr *target;
+  if (RPI_IS_DF(rpi))
+    {
+      target = &pif->iface->addr->ip; // Prune-Echo
+    }
+  else
+    {
+      if (!rpi->df)
+	{
+	  TRACE(D_PACKETS, "Cannot send %s(*, %I), there is no DF elected on the link.", (join ? "Join" : "Prune"), grp->ga);
+	  return 0;
+	}
+      target = &rpi->df->neigh->addr;
+    }
+
+  return pim_tx_jp(pif, target, grp, join);
+}
+
+/*
+ * Send a Join/Prune packet upstream.
+ */
+int
+pim_send_upstream_jp(struct pim_grp *grp)
+{
+  struct pim_proto *p = grp->proto;
+  int join = !EMPTY_LIST(grp->joined);
+
+  if (!grp->rp || !grp->rp->upstream)
+    {
+      TRACE(D_PACKETS, "\tCannot send upstream %s(*, %I), we have no upstream yet.", join ? "Join" : "Prune", grp->ga);
+      return 0;
+    }
+
+  return pim_send_jp(grp->rp->upstream->iface, grp, !EMPTY_LIST(grp->joined));
+}
+
+/*
+ * Join or Prune a group upstream. Sets up the timers to do it periodically.
+ */
+void
+pim_upstream_join(struct pim_grp *grp)
+{
+  struct pim_proto *p = grp->proto;
+  int join = !EMPTY_LIST(grp->joined);
+  int old_join = tm_active(grp->jt);
+
+  if (join == old_join)
+    return;
+
+  if (!grp->rp)
+    {
+      TRACE(D_EVENTS, "Group %I has no RPA assigned, cannot %s.", grp->ga, join ? "join" : "prune");
+      return;
+    }
+
+  TRACE(D_EVENTS, "%s group %I on upstream", join ? "Joining" : "Leaving", grp->ga);
+
+  struct pim_rp_iface *rpi = grp->rp->upstream;
+  if (rpi && rpi->df)
+    {
+      struct pim_iface *ifa = rpi->iface;
+      grp->jt->recurrent = ifa->cf->jp_periodic TO_S;
+      tm_start(grp->jt, 0);
+    }
+  else if (!join)
+    {
+      pim_grp_free(grp);
+    }
+}
+
+/*
+ * Join or Prune from downstream. Will add the interface into joined list,
+ * and Join/Prune the upstream if necessary.
+ */
+void
+pim_downstream_join(struct pim_grp *grp, struct iface *iface, int join)
+{
+  struct pim_proto *p = grp->proto;
+  struct pim_joined_iface *pji, *next;
+
+  struct pim_iface *pif = pim_iface_find(p, iface);
+  if (!pif)
+    {
+      log(L_WARN, "Unknown iface %s mc request for PIM.", iface->name);
+      return;
+    }
+
+  TRACE(D_EVENTS, "Iface %s %s group %I", iface->name, join ? "joined" : "left", grp->ga);
+
+  if (join)
+    {
+      pji = mb_allocz(p->p.pool, sizeof(*pji));
+      pji->iface = iface;
+      add_tail(&grp->joined, NODE pji);
+    }
+  else
+    {
+      WALK_LIST_DELSAFE(pji, next, grp->joined)
+	if (pji->iface == iface)
+	  rem_node(NODE pji);
+    }
+
+  pim_upstream_join(grp);
+  pim_rt_update(p, &grp->ga, grp->rp);
+}
+
+#define DROP(msg, args...) do { log(L_WARN msg, ##args); return; } while (0)
+
+void
+pim_jp_received(struct pim_proto *p, struct pim_jp_msg *msg, struct pim_jp_grp *grp, struct pim_neigh *n)
+{
+  if (grp->flags & PIM_JP_BIDIR == 0)
+    TRACE(D_PACKETS, "Group should not be managed by PIM-BIDIR.");
+
+  if (net_pxlen(&grp->ga) == 0)
+    bug("Wildcard group JP received, not implemented!");
+
+  if (!net_is_host(&grp->ga))
+    DROP("Received group JP notify with nontrivial prefix - not defined in RFC!");
+
+  if (grp->j_count + grp->p_count != 1)
+    DROP("Received group BIDIR Join/Prune with %u sources - nonsense!", grp->j_count + grp->p_count);
+
+  struct pim_jp_src *src = grp->j_count ? grp->j : grp->p; // Well, grp->j is always the right pointer, but...
+
+  if (src->flags & PIM_JP_WILDCARD == 0)
+    DROP("Not a wildcard source in BIDIR - nonsense!");
+
+  ip_addr prefix = net_prefix(&grp->ga);
+  struct pim_grp *grp_state = pim_grp_get(p, &prefix);
+
+  if (!ipa_equal(net_prefix(&src->addr), grp_state->rpa))
+  {
+    if (ipa_zero(grp_state->rpa))
+      {
+	grp_state->rpa = net_prefix(&src->addr);
+	grp_state->rp = pim_rp_get(p, &grp_state->rpa);
+	add_tail(&grp_state->rp->groups, NODE grp_state);
+	TRACE(D_PACKETS, "Different RPA in Join/Prune -> ignore!");
+      }
+    else
+      return; // silent drop
+  }
+
+  struct pim_neigh *target = pim_neigh_get(p, &msg->target, n->iface);
+
+  if (target->neigh->scope != SCOPE_HOST)
+    {
+      /* This message is not for us. Just watch it. */
+      struct pim_rp_iface *rpi = pim_rp_iface_find2(p, grp_state->rpa, n->iface->iface->index);
+
+      if (rpi->rp->upstream == rpi)
+	{
+	  TRACE(D_PACKETS, "Received upstream %s for group %I", grp->j_count ? "join" : "prune", grp_state->ga);
+	  struct pim_iface_config *cf = rpi->iface->cf;
+	  if (tm_active(grp_state->jt))
+	    tm_start_btime(grp_state->jt, grp->j_count
+	      ? cf->jp_periodic * 1.1 + random_u32() % cf->jp_periodic * 0.3
+	      : random_u32() % cf->override_interval * 0.9);
+	}
+      return;
+    }
+
+  struct pim_grp_iface *grpi = pim_grp_iface_get(grp_state, n->iface);
+
+  TRACE(D_PACKETS, "Received downstream %s for group %I", grp->j_count ? "join" : "prune", grp_state->ga);
+
+  if (grp->j_count)
+    {
+      if (msg->holdtime == PIM_HOLDTIME_INF)
+	tm_stop(grpi->et);
+      else
+	tm_start_btime(grpi->et, msg->holdtime);
+      tm_stop(grpi->ppt);
+
+      pim_request_join(grpi, 1);
+    }
+  else
+    tm_start_btime(grpi->ppt, grpi->iface->cf->override_interval);
+}
+
+/*
+ * Update the pim_neigh structure, either because we got neigh_notify, or
+ * because we got a hello / missed a few hellos.
+ */
+void
+pim_neigh_update(struct pim_neigh *pn)
+{
+  struct pim_proto *p = pn->iface->proto;
+  TRACE(D_EVENTS, "Neighbor update %I", pn->neigh->addr);
+
+  if (pn->flags & PIM_NF_NEW)
+    {
+      TRACE(D_EVENTS, "\tNew neighbor is UP %I", pn->neigh->addr);
+      pn->flags &= ~PIM_NF_NEW;
+    }
+
+  if (!(pn->flags & PIM_NF_UP))
+    {
+      TRACE(D_EVENTS, "\tNeighbor is DOWN %I", pn->neigh->addr);
+      pn->neigh->data = NULL;
+      rem_node(NODE pn);
+
+      node *n, *next;
+
+      WALK_LIST_DELSAFE(n, next, pn->df_list)
+	{
+	  struct pim_rp_iface *rpi = SKIP_BACK(struct pim_rp_iface, df_node, n);
+	  rpi->df = NULL;
+	  rpi->df_metric = PIM_METRIC_INFTY;
+	  pim_df_reelect(rpi);
+	  rem_node(n);
+	}
+      WALK_LIST_DELSAFE(n, next, pn->bo_list)
+	{
+	  struct pim_rp_iface *rpi = SKIP_BACK(struct pim_rp_iface, bo_node, n);
+	  rpi->bo = NULL;
+	  rpi->bo_metric = PIM_METRIC_INFTY;
+	  rem_node(n);
+	}
+
+      rfree(pn->hold);
+      mb_free(pn);
+      return;
+    }
+}
+
+void
+pim_neigh_notify(neighbor *n)
+{
+  if (!n->data) return;
+
+  struct pim_neigh *pn = (struct pim_neigh *) n->data;
+  struct pim_proto *p = pn->iface->proto;
+
+  TRACE(D_EVENTS, "Neighbor notify %I", n->addr);
+
+  if (n->scope <= 0)
+    pn->flags &= ~PIM_NF_UP;
+
+  pim_neigh_update(pn);
+}
+
+int
+pim_metric_better(struct pim_metric *new, struct pim_metric *old, ip_addr *new_addr, ip_addr *old_addr)
+{
+  if (new->pref < old->pref)
+    return 1;
+  if (new->pref > old->pref)
+    return 0;
+
+  if (new->metric < old->metric)
+    return 1;
+  if (new->metric > old->metric)
+    return 0;
+
+  if (new_addr && old_addr)
+    if (ipa_compare(*new_addr, *old_addr) <= 0)
+      return 1;
+
+  return 0;
+}
+
+/*
+ * Get the metric to be announced on interface in DF messages.
+ * Ensures we always announce infinite metric on upstream.
+ */
+struct pim_metric
+pim_get_metric(struct pim_rp_iface *rpi)
+{
+  struct pim_rp *rp = rpi->rp;
+
+  if (rp->upstream == rpi)
+    return PIM_METRIC_INFTY;
+
+  return rp->rp_metric;
+}
+
+void
+pim_df_accept(struct pim_iface* ifa, struct pim_df_msg *msg)
+{
+  struct pim_proto *p = ifa->proto;
+
+  struct pim_rp_iface *rpi = pim_rp_iface_get(p, msg->rpa, ifa->iface);
+  pim_df_message(rpi, msg);
+}
+
+/*
+ * A routing change occured, such that the path to one of our RPAs was changed.
+ * Walk through every RP and fill its upstream and metric.
+ */
+static void
+pim_rpf_update(void *P)
+{
+  struct pim_proto *p = P;
+  TRACE(D_EVENTS, "Scheduled RPF interface update running.");
+  HASH_WALK(p->rp_states, next, rp)
+  {
+    pim_rp_fill_rpf(rp);
+  }
+  HASH_WALK_END;
+}
+
+static void
+pim_rt_notify(struct proto *P, struct channel *c, net *n, rte *new, rte *old, ea_list *attrs)
+{
+  struct pim_proto *p = (struct pim_proto *) P;
+  struct net_addr *addr = n->n.addr;
+
+  switch (addr->type)
+    {
+      case NET_IP4:
+      case NET_IP6:
+	if (!ev_active(p->rpf_update) && trie_match_net(p->rp_trie, addr))
+	  /* We have a RP which is affected by this route. Recalculate the RP trees. */
+	  ev_schedule(p->rpf_update);
+	return;
+
+      case NET_MREQ4:
+      case NET_MREQ6:
+	/* Because we receive only optimal route updates, we care only about
+	 * the first and the last route announced. Having both or none means
+	 * nothing changes for us. */
+	if ((new == NULL) == (old == NULL))
+	  return;
+
+	ip_addr ga = net_prefix(addr);
+	struct pim_grp *grp = pim_grp_get(p, &ga);
+	struct iface *iface = if_find_by_index(net_ifindex(addr));
+	pim_downstream_join(grp, iface, new != NULL);
+	return;
+
+      case NET_MGRP4:
+      case NET_MGRP6:
+      default:
+	return;
+    }
+}
+
+static void
+pim_if_notify(struct proto *P, uint flags, struct iface *iface)
+{
+  struct pim_proto *p = (struct pim_proto *) P;
+  struct pim_config *c = (struct pim_config *) P->cf;
+
+  if (iface->flags & IF_IGNORE)
+    return;
+
+  if (flags & IF_CHANGE_UP)
+    {
+      struct pim_iface_config *ic;
+      ic = (struct pim_iface_config *) iface_patt_find(&c->patt_list, iface, iface->addr);
+      if (!ic)
+	  ic = &c->default_iface_cf;
+      pim_iface_new(p, iface, ic);
+      return;
+    }
+
+
+  if (flags & IF_CHANGE_DOWN)
+    {
+      struct pim_iface * ifa = pim_iface_find(p, iface);
+      pim_iface_down(ifa);
+      pim_iface_free(ifa);
+    }
+}
+
+static int
+pim_start(struct proto *P)
+{
+  struct pim_proto *p = (struct pim_proto *) P;
+  TRACE(D_EVENTS, "PIM protocol starting");
+
+  init_list(&p->iface_list);
+
+  HASH_INIT(p->rp_states, P->pool, 8);
+  HASH_INIT(p->rpi_states, P->pool, 8);
+  HASH_INIT(p->grp_states, P->pool, 8);
+
+  fib_init(&p->groups, P->pool, pim_is_ipv6(p) ? NET_IP6 : NET_IP4,
+    sizeof(struct pim_grp), 0, 0, NULL);
+
+  linpool *lp = lp_new(P->pool, sizeof(struct f_trie_node));
+  p->rp_trie = f_new_trie(lp, sizeof(struct f_trie_node));
+
+  struct pim_grp_config *grp;
+  WALK_LIST(grp, p->cf->grp_list)
+  {
+    struct pim_grp_rpa *gr = fib_get(&p->groups, &grp->ga);
+    gr->px = grp->ga;
+    gr->rpa = grp->rpa;
+    if (!ipa_equal(grp->rpa, IPA_NONE))
+      pim_rp_get(p, &grp->rpa);
+  }
+
+  return PS_UP;
+}
+
+static int
+pim_shutdown(struct proto *P)
+{
+  struct pim_proto *p = (struct pim_proto *) P;
+  struct pim_iface *ifa;
+  WALK_LIST_FIRST(ifa, p->iface_list)
+  {
+    pim_send_hello(ifa, 0);
+    pim_iface_down(ifa);
+    pim_iface_free(ifa);
+  }
+
+  return PS_DOWN;
+}
+
+static void
+pim_dump(struct proto *P)
+{
+  static char *dfStates[] = {"BUG", "Offer", "Winner", "Backoff", "Lose"};
+  struct pim_proto *p = (struct pim_proto *) P;
+  struct pim_iface *ifa;
+  WALK_LIST(ifa, p->iface_list)
+    pim_iface_dump(ifa);
+
+  HASH_WALK(p->grp_states, next, grp)
+    {
+      debug("\tGroup %I, RP %I, ", grp->ga, grp->rpa);
+      debug("PIM joins:");
+      struct pim_grp_iface *grpi;
+      WALK_LIST(grpi, grp->iface_list)
+	debug(" %s%s", grpi->iface->iface->name, tm_active(grpi->ppt) ? " (prune pending)" : "");
+      debug("; joined on:");
+      struct pim_joined_iface *ji;
+      WALK_LIST(ji, grp->joined)
+	  debug(" %s", ji->iface->name);
+      debug("\n");
+    }
+  HASH_WALK_END;
+
+  HASH_WALK(p->rp_states, next, rp)
+    {
+      debug("\tRP %I, RPF %s\n", rp->rpa, rp->upstream ? rp->upstream->iface->iface->name : "[no upstream]");
+      struct pim_rp_iface *rpi;
+      WALK_LIST(rpi, rp->iface_list)
+	debug("\t\tiface %s, DF state: %s, DF: %I\n", rpi->iface->iface->name, dfStates[rpi->election_state], rpi->df ? rpi->df->neigh->addr : IPA_NONE);
+    }
+  HASH_WALK_END;
+}
+
+int pim_rte_same(rte *e1, rte *e2)
+{
+  if (e1->attrs->dest == RTD_MULTICAST)
+    return RTE_MGRP_SAME(e1->u.mkrt.iifs, e2->u.mkrt.oifs);
+  return 1;
+}
+
+
+static struct proto *
+pim_init(struct proto_config *c)
+{
+  struct proto *p = proto_new(c);
+  struct pim_proto *pim = (struct pim_proto *) p;
+  struct pim_config *pim_c = (struct pim_config *) c;
+
+  pim->use_ipv6 = c->net_type == NET_MGRP6;
+
+  pim->mrib_channel   = proto_add_channel(p, proto_cf_find_channel(c, !pim->use_ipv6 ? NET_IP4   : NET_IP6));
+  pim->mreq_channel   = proto_add_channel(p, proto_cf_find_channel(c, !pim->use_ipv6 ? NET_MREQ4 : NET_MREQ6));
+  pim->mroute_channel = proto_add_channel(p, proto_cf_find_channel(c, !pim->use_ipv6 ? NET_MGRP4 : NET_MGRP6));
+
+  p->rt_notify = pim_rt_notify;
+  p->if_notify = pim_if_notify;
+  p->rte_same = pim_rte_same;
+
+  pim->rpf_update = ev_new(p->pool);
+  pim->rpf_update->data = pim;
+  pim->rpf_update->hook = pim_rpf_update;
+
+  pim->cf = pim_c;
+
+  return p;
+}
+
+struct protocol proto_pim = {
+	.name =		"PIM",
+	.template =	"pim%d",
+	.preference =	DEF_PREF_STATIC,
+	.channel_mask = NB_ANY,
+	.proto_size =	sizeof(struct pim_proto),
+	.config_size =	sizeof(struct pim_config),
+	.init =		pim_init,
+	.dump =		pim_dump,
+	.start =	pim_start,
+	.shutdown =	pim_shutdown,
+};
+
diff --git a/proto/pim/pim.h b/proto/pim/pim.h
new file mode 100644
index 0000000..ba0f7a5
--- /dev/null
+++ b/proto/pim/pim.h
@@ -0,0 +1,335 @@
+/*
+ *  BIRD -- PIM protocol, variant BIDIR-PIM
+ *
+ *  (c) 2016 Ondrej Hlavaty <aearsis@eideo.cz>
+ *
+ *  Can be freely distributed and used under the terms of the GNU GPL.
+ */
+
+#ifndef _BIRD_PIM_H_
+#define _BIRD_PIM_H_
+
+#include "nest/bird.h"
+#include "nest/iface.h"
+#include "nest/protocol.h"
+#include "nest/route.h"
+#include "conf/conf.h"
+#include "lib/socket.h"
+#include "lib/hash.h"
+#include "nest/locks.h"
+#include "filter/filter.h"
+
+/***************
+  Configuration
+ ***************/
+
+struct pim_grp_config
+{
+  node n;				/* member of pim_config->grp_list */
+  net_addr ga;				/* multicast group address prefix */
+  ip_addr rpa;				/* rendezvous point address */
+};
+
+struct pim_iface_config
+{
+  struct iface_patt i;			/* member of pim_config->patt_list */
+
+  uint election_robustness;
+
+  btime hello_int;			/* hello period */
+  btime hello_dly;			/* intial hello delay */
+  btime hello_holdtime;			/* hello holdtime transmitted to neighbors */
+
+  btime jp_periodic;			/* join/prune period (t_periodic) */
+  btime jp_holdtime;			/* holdtime in upstream joins (should be 3.5 * jp_periodic) */
+  btime override_interval;		/* join/prune override interval */
+};
+
+struct pim_config
+{
+  struct proto_config c;
+  u8 use_ipv6;
+
+  list grp_list;			/* list of group configs (struct pim_grp_config) */
+  list patt_list;			/* list of ifaces (struct pim_iface_config) */
+
+  struct pim_iface_config default_iface_cf;
+};
+
+/***************
+     Runtime
+ ***************/
+
+struct pim_grp_rpa
+{
+  struct fib_node n;			/* member of pim_proto->groups */
+  net_addr px;				/* when a group matches this prefix... */
+  ip_addr rpa;				/* .. it is assigned RPA. */
+};
+
+struct pim_iface
+{
+  node n;				/* member of pim_proto->iface_list */
+  struct pim_proto *proto;
+  struct iface *iface;
+  struct pim_iface_config *cf;
+  list neigh_list;			/* list of neighbors on this iface (struct pim_neigh) */
+
+  struct object_lock *lock;
+
+  u32 gen_id;				/* generation ID sent in hello messages */
+  sock *sk;
+
+  uint pkt_len;				/* length of a packet being constructed in tx buffer */
+  int group_count_offset;		/* number of groups while constructing tx join/prune packet (relative to tx buf) */
+
+  timer *hello_timer;			/* periodic hello timer */
+  u8 hello_sent;			/* assert sending hello before any join */
+
+  list grp_list;			/* list of pim_grp_iface to be freed along with this */
+};
+
+struct pim_metric
+{
+    u32 pref, metric;
+};
+
+#define PIM_METRIC_INFTY ((struct pim_metric){ .pref = -1U, .metric = -1U })
+
+struct pim_rp
+{
+  node n;				/* member of pim_proto->rp_list */
+  struct pim_rp *next;			/* member of pim_proto->rp_hash */
+  struct pim_proto *proto;
+
+  ip_addr rpa;
+  struct pim_metric rp_metric;		/* my metric towards RPA */
+
+  struct pim_rp_iface *upstream;	/* RPI towards RPA */
+
+  list iface_list;			/* iface specific states (list of pim_rp_iface) */
+  list groups;				/* groups having this RPA (for route updates) */
+};
+
+struct pim_rp_iface
+{
+  node n;				/* member of pim_rp->iface_list */
+  struct pim_rp_iface *next;		/* member of pim_proto->rpi_states */
+  struct pim_rp *rp;
+  struct pim_iface *iface;
+
+  /* Designated Forwarder */
+  struct pim_neigh *df;
+  struct pim_metric df_metric;
+  node df_node;				/* member of pim_neigh->df_list */
+
+  /* DF election */
+  u8 election_state;			/* PIM_DF_* */
+  timer *election_timer;		/* timer used in election */
+  u8 mc;				/* message count - different meaning in every state */
+
+  /* Best offer stored in the Backoff state */
+  struct pim_neigh *bo;
+  struct pim_metric bo_metric;
+  node bo_node;				/* member of pim_neigh->bo_list */
+};
+
+struct pim_grp
+{
+  node n;				/* member of pim_rp->groups */
+  struct pim_grp *next;			/* member of pim_proto->groups */
+  struct pim_proto *proto;
+
+  ip_addr ga;				/* group address */
+  ip_addr rpa;				/* Rendezvous Point address */
+  struct pim_rp *rp;			/* RP state, if RPA is not zero */
+
+  timer *jt;				/* Upstream Join timer */
+
+  list joined;				/* list of joined ifaces (by any means) - pim_joined_iface */
+  list iface_list;			/* list of ifaces joined by PIM - pim_grp_iface */
+};
+
+struct pim_joined_iface
+{
+  node n;				/* member of pim_grp->joined */
+  struct iface *iface;
+};
+
+struct pim_grp_iface
+{
+  node n;				/* member of pim_grp->iface_list */
+  node iface_node;			/* member of pim_iface->grp_list */
+  struct pim_iface *iface;
+  struct pim_grp *grp;
+
+  /* Managed by join/prune part */
+  timer *et;				/* join expiry timer */
+  timer *ppt;				/* prune pending timer */
+};
+
+struct pim_neigh
+{
+    node n;				/* member of pim_iface->neigh_list */
+    neighbor *neigh;
+    struct pim_iface *iface;
+
+    timer *hold;			/* neighbor liveness timer */
+    u32 gen_id;				/* neighbor's Gen ID */
+
+    u8 flags;				/* combination of PIM_NEIGH_* */
+
+    list df_list;			/* RPIs where this neighbor is the acting DF */
+    list bo_list;			/* RPIs where this neighbor has the best offer on Backoff state */
+};
+
+struct pim_proto
+{
+  struct proto p;
+  struct pim_config *cf;
+
+  u8 use_ipv6;
+
+  struct channel *mrib_channel;		/* MRIB unicast routing topology - read only */
+  struct channel *mreq_channel;		/* Table of requests group address -> interface */
+  struct channel *mroute_channel;	/* Table of multicast routes */
+
+  struct fib groups;			/* configured group prefixes (struct pim_grp_rpa) */
+  list iface_list;			/* list of managed ifaces (struct pim_iface) */
+
+  HASH(struct pim_grp) grp_states;	/* active groups */
+  HASH(struct pim_rp) rp_states;	/* known RPs */
+  HASH(struct pim_rp_iface) rpi_states;	/* States for (RP, iface) */
+
+  struct f_trie *rp_trie;		/* trie of RPA that we need to take care about (used to filter route updates) */
+
+  event *rpf_update;			/* optimal path to some RPA changed */
+};
+
+/* Default values for pim_iface */
+#define PIM_DEFAULT_ELECTION_ROBUSTNESS     3
+#define PIM_DEFAULT_HELLO_INT          (30 S)
+#define PIM_DEFAULT_HELLO_DLY           (5 S)
+#define PIM_DEFAULT_HELLO_HOLDTIME    (105 S)
+#define PIM_DEFAULT_OVERRIDE_INTERVAL   (3 S)
+#define PIM_DEFAULT_JP_PERIODIC        (60 S)
+
+/* Some constants defined in RFC 4601 */
+#define PIM_PROTO                         103
+#define PIM_HOLDTIME_DEF                  105
+#define PIM_HOLDTIME_INF               0xffff
+#define PIM_OFFER_PERIOD             (100 MS)
+#define PIM_BACKOFF_PERIOD              (1 S)
+
+/* Neigh flags (pim_neigh->flags) */
+#define PIM_NF_NEW                       0x01
+#define PIM_NF_UP                        0x02
+#define PIM_NF_BIDIR                     0x04
+
+/* Hello option types - in host order */
+#define PIM_HLO_OPT_HOLDTIME                1
+#define PIM_HLO_OPT_GENID                  20
+#define PIM_HLO_OPT_BIDIR_CAPABLE          22
+
+/* IANA Adress Family Numbers */
+#define PIM_AFN_IP4                         1
+#define PIM_AFN_IP6                         2
+
+#define pim_is_ipv6(p) ((p)->use_ipv6)
+
+/***********
+   Packets
+ ***********/
+
+struct pim_df_msg
+{
+  u8 type;				/* One of PIM_DF_* */
+  ip_addr rpa;
+
+  struct pim_neigh *sender;
+  struct pim_metric metric;
+
+  ip_addr target;			/* New Winner in Pass msg, Offering in Backoff */
+  struct pim_metric target_metric;
+  btime backoff_interval;
+};
+
+/* Constants used by both DF packet type and DF state */
+#define PIM_DF_OFFER	1
+#define PIM_DF_WINNER	2
+#define PIM_DF_BACKOFF	3
+#define PIM_DF_PASS	4
+#define PIM_DF_LOSE	PIM_DF_PASS
+
+#define RPI_IS_DF(rpi) (rpi->election_state & 2)
+
+struct pim_jp_src
+{
+    net_addr addr;
+    u8 flags;
+};
+
+#define PIM_JP_RPT          1
+#define PIM_JP_WILDCARD     2
+#define PIM_JP_SPARSE       4
+
+struct pim_jp_grp			/* Used while decoding jp packets */
+{
+    net_addr ga;
+    u16 j_count, p_count;
+    struct pim_jp_src *j, *p;
+    u8 flags;
+};
+
+#define PIM_JP_BIDIR      128
+
+struct pim_jp_msg
+{
+    ip_addr target;
+    u8 num_groups;
+    btime holdtime;
+};
+
+/* packets.c */
+int pim_sk_open(struct pim_iface *ifa);
+int pim_send_hello(struct pim_iface *ifa, uint holdtime);
+int pim_send_df(struct pim_rp_iface *rpi, struct pim_df_msg *msg);
+int pim_send_upstream_jp(struct pim_grp *grp);
+int pim_tx_jp(struct pim_iface *pif, ip_addr *target, struct pim_grp *grp, int join);
+
+/* df.c */
+void pim_df_message(struct pim_rp_iface *rpi, struct pim_df_msg *msg);
+void pim_df_timer_expired(timer* t);
+void pim_df_reelect(struct pim_rp_iface *rpi);
+void pim_df_metric_changed(struct pim_rp_iface *rpi, struct pim_metric old_metric);
+
+/* pim.c */
+struct pim_grp *pim_grp_find(struct pim_proto *p, ip_addr *ga);
+struct pim_iface *pim_iface_find(struct pim_proto *p, struct iface *ifa);
+
+struct pim_rp *pim_rp_find(struct pim_proto *p, ip_addr *rpa);
+struct pim_rp * pim_rp_get(struct pim_proto *p, ip_addr *rpa);
+void pim_rp_update_routing(struct pim_rp *rp);
+
+struct pim_neigh *pim_neigh_from_neighbor(struct neighbor *n);
+struct pim_neigh *pim_neigh_find(struct pim_proto *p, ip_addr *a, struct pim_iface *ifa);
+struct pim_neigh *pim_neigh_get(struct pim_proto *p, ip_addr *a, struct pim_iface *ifa);
+
+int pim_send_jp(struct pim_iface *pif, struct pim_grp *grp, int join);
+int pim_send_jp_all(struct pim_rp *rp, struct pim_neigh *target, int join);
+void pim_jp_upstream_notify(struct pim_grp *grp);
+void pim_jp_received(struct pim_proto *p, struct pim_jp_msg *msg, struct pim_jp_grp *grp, struct pim_neigh *n);
+void pim_neigh_update(struct pim_neigh *n);
+void pim_df_accept(struct pim_iface *ifa, struct pim_df_msg *msg);
+void pim_upstream_neighbor_change(struct pim_rp *rp, struct pim_neigh *old, struct pim_neigh *new);
+void pim_need_hello(struct pim_iface *ifa);
+
+void pim_config_init(struct pim_config *);
+void pim_config_finish(struct pim_config *);
+void pim_iface_config_init(struct pim_iface_config *);
+void pim_iface_config_finish(struct pim_iface_config *);
+
+int pim_metric_better(struct pim_metric *new, struct pim_metric *old, ip_addr *new_addr, ip_addr *old_addr);
+struct pim_metric pim_get_metric(struct pim_rp_iface *rpi);
+
+#endif
-- 
2.8.3

