\chapter{Multicast in IPv4}

IP multicast was added as an additional addressing model to unicast. First
references can be found in \rfc{966}. This RFC defines multicast traffic
with many responsibilities for routers (called "multicast agents" in that time)
and was soon obsoleted. Latest specification can be found in \rfc{1112}.

In local networks, multicasts are similar to broadcasts. Every packet is to be
transmitted to every host on that link, and host can decide according to
destination address whether or not to receive and process or drop it.

Differences are notable on internetwork level. While broadcasts should be
either forwarded to all links or filtered completely by routers, multicasts
should have more controled behavior.

\section{Multicast group}

First term we need to understand is multicast group. It is represented by an IP
address allocated from dedicated region \prefix{224.0.0.0/4}. It is further
divided (as per \rfc{5771}) to:

\begin{tabular}{r@/l l}
	224.0.0&24	& Local Network Control Block \\
	224.0.1&24	& Internetwork Control Block \\
	224.2&16	& SDP/SAP Block \\
	232&8		& Source-Specific Multicast Block \\
	233&8		& GLOP Block \\
	239&8		& Administratively Scoped Block \\
\end{tabular}

And to AD-HOC blocks in between.

Host membership in group is fully optional. Neither number of members in group,
nor number of groups host belongs to, is limited and can be even zero. Host
does not have to belong to group to send packets into it. Packets are
distributed in the same "best effort" manner as unicast ones -- can be
delivered to all, some or no hosts, in any order.

There are three levels of conformance with IP multicast. Level 0 means no
conformance. Level 1 requires host to be able to send packets to multicast
groups. This level still requires little little code in networking stack, because
sending packet to multicast group is very similar to sending it as unicast
packet with destination set to the group address. While it doesn't make much
sense to send unicast packets destinated outside local network prefix directly
to link, it is expected behavior with multicast.

Level 2 means fully conformant, and requires implementation of the host part of
Internet Group Management Protocol (IGMP).

\section{Internet Group Management Protocol}

Current version of IGMP is 3, and is described in \rfc{3376}. However, all
versions are backward compatible. All nodes in one network fall back to the
least version that all of them support.

Purpose of IGMP is to exchange information between hosts and routers about
group membership. Note that it is mandatory to implement IGMP to be part of
multicast group, but until multicast packet crosses boundary of one network, it
is delivered as broadcast to all hosts. As such all hosts receive it without
the routers knowledge.

Let us start with IGMP version 1 specified in Appendix I. of \rfc{1112}. There
are just two types of messages: membership query and membership report.
Membership query is sent periodically by routers, and announces to hosts there
is IGMPv1 capable router. This query is sent to group \ip{224.0.0.1} with TTL
1, and therefore is local network limited. Every host is ought to be member of
this group, hence the common name ALL-HOSTS. When hosts receives query, replies
with membership report in random delay up to 10 seconds. No host should send
a report for this group.

Report is sent to the group being reported. As noted above, host does not have
to report to listen. Filtering multicast traffic is made by other means.
Sending a report declares there is someone interested in this group on this
particular link. When, during the random delay, host receives a report, it
stops his own timer and remain silent. This reduces the amount of control
traffic. When host decides to leave a group, it does nothing. If it was the
only host in that group, on the next query no one will report and routers will
stop forwarding.

IGMPv2 \cite{rfc2236} comes with some major changes. First, router can send
query to one specific group. That means it can keep timer for every group
separately, and asking for reports does not generate unnecessary trafic in
every other group. Second, the maximum delay between query and report
(previously fixed 10 seconds) is now specified in each query, and is
configurable. Network administrator can tune this variable for his needs. By
turning it down, hosts will reply faster and routers can faster stop
forwarding. Giving longer delays can improve stability on very slow or
unreliable links.

The most notable change though is new message type - leave group. When host
sends a report, it sets a flag. Other hosts without flag remain silent. When
flagged host leaves a group, it sends the leave group message. Other hosts
react to orher hosts leave in similar way to query. When router hears leave,
it starts a timer. This timer can be stopped by receiving report. Expiring this
timer immediately changes this group state to not having any members. This way
less unnecessary traffic is forwarded.

IGMPv3 comes with additional fields and more complex protocol logic. It is
dedicated to source-specific multicast forwarding and includes messages to keep
set of sources hosts on current link want to receive.

For purpose of this thesis, only IGMPv2 was implemented, as PIM-BIDIR is not
source specific routing protocol.

\TODO More about backward compatibility?

\section{Link layer}

Even though multicast is specified on network layer, it needs some level of
support from link layer. Let me explain how multicast traffic integrates with
the most common combination of IP over ethernet.

First problem we need to solve is, which link layer address to use for
multicast group addresses. When sending unicast packet, ARP is used to
determine link layer address. As multicast is technically a broadcast on link
layer, it would be possible to use broadcast address \mac{FF:FF:FF:FF:FF:FF}.

But that would mean every multicast packet on network must be received by all
hosts and examined by operating systems, because there is no way how to filter
it on hardware level. For this purpose, every ethernet address that starts with
1 (that means, the least significant bit of the first byte) is considered to be
broadcast address and is to be flooded to all nodes on this network. Network
hardware generally do not make difference between them. So We can associate
specific meaning to diferent MAC addresses.

For IPv4 multicast, region of MAC addresses was allocated. This region starts
at \mac{01:00:5E:00:00:00} and ends with \mac{01:00:5E:7F:FF:FF}. To construct
MAC address from multicast group address, one puts lower 23 bits of IP address
to lower bits of the MAC address.

This way, network interfaces can implement rough filter, that can drop frames
host knows nothing about. Additional filtering is still needed because of those
missing bits.

Multicast router needs to receive packets for all groups, because IGMP reports
are sent there. To enable this behavior NICs often have "all multicast" mode,
which lets al multicast frames pass through. Or we can put the NIC to
promiscuous mode, which passes all frames to CPU.

Receiving all those packets in daemon is another story.

\section{Kernel implementation}

Kernel interface for multicast is pretty complicated. At least differences
between UNIXes are not big.

When application wants to receive unicast trafic, it opens a socket:

\TODO{Example -- code to open socket}

\noindent Then, joining and leaving groups are made by setsockopt calls:

\TODO{Example -- code calling join}

One thing to note here. When there is socket opened which joined group, the host
itself joins the group y means of IGMP. And when host is joined, every other
multicast enabled socket will get packets addressed to that group. So, you
still need to filter those at application level.

\noindent When router wants to receive all IGMP packets for all groups, it
would have to join every group possible. That is certainly not the way to go.

IGMPv2 suggests using IP option Router Alert. Every IP packet with this option
set should be passed to sockets which orders it by this setsockopt call:

\TODO{Example -- code calling setsockopt IP\_ROUTER\_ALERT}

\noindent There are multiple problems with this. Backward compatibility with IGMPv1 is
broken, and standard does not force hosts to do so -- and some (e.g. old Cisco)
routers do not do it.

To my surprise, there is only one way how to get all IGMP packets coming on
some interface. That is opening the IGMP control socket.

\subsection{IGMP control socket}

When we want to control kernel multicast routing tables, we need to open
control socket. That is, raw IP socket with type \texttt{IPPROTO\_IGMP}. Then,
sequence of setsockopt calls is needed:

\TODO{Example -- socket, MRT\_INIT, MRT\_PIM}

There can be only one socket on which MRT\_INIT succeeds. This is the one
control socket, through which we can control multicast routing tables.

This part could be relatively easily rewritten (at kernel side) to some sane
netlink api. But there is more -- this is the only socket, which receives all
IGMP packets.

So, it is not even theoretically possible to run mmore than one multicast
routing daemon on one system.\footnote{Unless isolating them in different
network namespaces, more about it later.}
